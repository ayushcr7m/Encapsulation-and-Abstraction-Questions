ERROR IDENTIFYING:
ENCAPSULATION:

Que 1: 

class Person {
    private String name;

    void display() {
        System.out.println("Name: " + name);
    }
}

public class Test {
    public static void main(String[] args) {
        Person p = new Person();
        p.name = "John";
        p.display();
    }
}


Question: What is the error in the above code?
Answer: The name variable is private and cannot be accessed directly outside the Person class.

Follow-up: How can we access name while maintaining encapsulation?
Answer: We should create public getter and setter methods to access and modify name safely.


Que 2:
class BankAccount {
    private double balance;
}

public class Test {
    public static void main(String[] args) {
        BankAccount acc = new BankAccount();
        System.out.println(acc.balance);
    }
}

Question: Why does this code fail to compile?
Answer: The balance variable is private, and there is no method to access it from outside the class.

Follow-up: How can we access the balance variable correctly?
Answer: We should add a public getter method:
public double getBalance() {
    return balance;
}


Que 3:
class Student {
    private int rollNo;
}

public class Test {
    public static void main(String[] args) {
        Student s = new Student();
        s.rollNo = 101;    }
}

Question: Why is s.rollNo = 101; causing an error?
Answer: The rollNo field is private, so it cannot be accessed directly outside the Student class.

Follow-up: How can we modify rollNo without making it public?
Answer: Use a setter method:
public void setRollNo(int rollNo) {
    this.rollNo = rollNo;
}


Que 4:
class Car {
    private String model;

    public void setModel() {
        this.model = model;
    }
}

Question: What is wrong with the setModel method?
Answer: The method does not take a parameter, so model remains unchanged.

Follow-up: How should the correct setter method be written?
Answer:
public void setModel(String model) {
    this.model = model;
}


Que 5:

class Employee {
    private int id;

    public int getId() {
    }
}

Question: Why is the getId() method incorrect?
Answer: The method does not return a value, so it does not compile.

Follow-up: How can we correct it?
Answer:
public int getId() {
    return id;
}


Que 6:
class Rectangle {
    private double length;
    private double width;

    void updateLength(double len) {
        length = len;    }
}

Question: Why is the updateLength() method violating encapsulation principles?
Answer: The method directly modifies the private variable without a setter method, reducing control over data modification.

Follow-up: What is the proper way to update length while maintaining encapsulation?
Answer: Use a public setter method:
public void setLength(double length) {
    this.length = length;
}

Que 7:
class Laptop {
    private String brand;

    private void showBrand() {
        System.out.println("Brand: " + brand);
    }
}

public class Test {
    public static void main(String[] args) {
        Laptop l = new Laptop();
        l.showBrand();
    }
}

Question: Why does the call l.showBrand(); result in an error?
Answer: The showBrand() method is private and cannot be accessed from outside the Laptop class.

Follow-up: How can we allow controlled access to showBrand()?
Answer: Change the method to public or provide a public method to call it:
public void displayBrand() {
    showBrand();
}


Que 8:
class Phone {
    private Phone() {
        System.out.println("Phone object created");
    }
}

public class Test {
    public static void main(String[] args) {
        Phone p = new Phone();
    }
}

Question: Why does the above code cause an error?
Answer: The constructor is private, preventing object creation from outside the class.

Follow-up: In which scenario would making a constructor private be useful?
Answer: It is useful in Singleton design patterns, where only one instance of a class is allowed.


Que 9:
class User {
    private String password;
}

public class Test {
    public static void main(String[] args) {
        User u = new User();
        System.out.println(u.password);
    }
}

Question: Why can't we print password directly?
Answer: The password field is private and cannot be accessed outside the User class.

Follow-up: How can we securely retrieve and modify the password?
Answer: Provide getter and setter methods with validation:
public void setPassword(String password) {
    if (password.length() >= 6) {
        this.password = password;
    } else {
        System.out.println("Password too short");
    }
}

public String getPassword() {
    return "****"; // Masked for security
}

Que 10:
class Book {
    private String title;

    public void setTitle(String title) {
        title = title; // Error
    }
}

Question: Why does setTitle() fail to update title?
Answer: The local parameter title is shadowing the instance variable, so this.title remains unchanged.

Follow-up: How can we properly update the title variable?
Answer: Use this to refer to the instance variable:
public void setTitle(String title) {
    this.title = title;
}

Que 11:
class Account {
    private double balance = 5000;
}

public class Test {
    public static void main(String[] args) {
        Account acc = new Account();
        System.out.println(acc.balance);
    }
}

Question: Why does this code fail?
Answer: The balance variable is private and cannot be accessed directly outside the class.

Follow-up: How can we access balance while maintaining encapsulation?
Answer: Use a public getter method.

Que 12:
class User {
    private String password;
    
    public String getPassword() {
        return password;
    }
}
public class Test {
    public static void main(String[] args) {
        User u = new User();
        u.password = "abc123";
    }
}

Question: What is the issue in this code?
Answer: password is private, so it cannot be modified directly.

Follow-up: How can we allow modification while keeping encapsulation?
Answer: Add a setter method.

Que 13:
class Car {
    public String model;
}
public class Test {
    public static void main(String[] args) {
        Car c = new Car();
        c.model = "Tesla";
    }
}

Question: Does this violate encapsulation?
Answer: Yes, because the field is public, allowing direct modification.

Follow-up: How should we fix this?
Answer: Declare model as private and use getter/setter methods.

Que 14:
class Student {
    private String name;
    
    Student(String studentName) {}
    
    public String getName() {
        return name;
    }
}
public class Test {
    public static void main(String[] args) {
        Student s = new Student("John");
        System.out.println(s.getName());
    }
}

Question: Why does this code return null?
Answer: The constructor does not assign studentName to name.

Follow-up: How can we fix this?
Answer: Assign this.name = studentName; inside the constructor.

Que 15:
class Logger {
    private Logger() {} // Private constructor
}
public class Test {
    public static void main(String[] args) {
        Logger log = new Logger();
    }
}

Question: Why does this code fail?
Answer: A private constructor prevents object instantiation outside the class.

Follow-up: When would using a private constructor be useful?
Answer: In Singleton design patterns.

ABSTRACTION:

Que 1:
abstract class Game {
    abstract void start();
}

public class Test {
    public static void main(String[] args) {
        Game g;
        g.start();
    }
}

Question: Why does this code fail to compile?
Answer: The reference g is declared but not initialized.

Follow-up: How can we fix this while maintaining abstraction?
Answer: Instantiate a subclass or use an anonymous class.

Que 2:
class Worker {
    abstract void performTask();
    abstract void takeBreak();
}

Question: What mistake does this code contain?
Answer: A class containing abstract methods must itself be declared abstract.

Follow-up: How can we fix it?
Answer: Add abstract before class Worker.

Que 3:
abstract class Robot {
    private abstract void process();
}

Question: Why does this code fail?
Answer: Abstract methods must be at least protected or public so subclasses can implement them.

Follow-up: What should be the correct access modifier?
Answer: Use protected or public.

Que 4:
abstract class Bank {
    static abstract void loanPolicy();
}

Question: What is wrong with this declaration?
Answer: Abstract methods cannot be static because they must be overridden in a subclass.

Follow-up: What happens if we remove static?
Answer: The code will compile correctly.

Que 5:
abstract class Animal {
    abstract void makeSound();
}

class Dog extends Animal {
    void makeSound(int x) {
        System.out.println("Bark");
    }
}


Question: Why does Dog still show an error?
Answer: The method signature does not match the abstract method's signature.

Follow-up: How should we correct this?
Answer: Change the method signature to void makeSound().

Que 6:
interface Engine {
    Engine() {
        System.out.println("Engine Created");
    }
}

Question: What is the issue with this code?
Answer: Interfaces cannot have constructors.

Follow-up: Why?
Answer: Because interfaces do not have instance variables to initialize.

Que 7:
interface Printer {
    void print();
    void scan();
}

class LaserPrinter implements Printer {
    public void print() {
        System.out.println("Printing...");
    }
}

Question: What problem does this code have?
Answer: The LaserPrinter class does not implement the scan() method.

Follow-up: How can we fix it?
Answer: Either implement scan() or declare LaserPrinter as abstract.

Que 8:
abstract class Gadget {
    abstract void charge();
}

class Phone extends Gadget {}

public class Test {
    public static void main(String[] args) {
        Phone p = new Phone();
        p.charge();
    }
}

Question: Why does this cause an error?
Answer: The Phone class does not implement the charge() method.

Follow-up: How do we correct it?
Answer: Implement charge() inside Phone.

Que 9:
interface Sound {
    void play();
    void stop();
}

abstract class MusicPlayer implements Sound {
    public void play() {
        System.out.println("Playing music...");
    }
}

Question: Why does MusicPlayer compile successfully even though it doesn’t implement stop()?
Answer: Because MusicPlayer is abstract, it is not required to implement all interface methods.

Follow-up: What happens if we make MusicPlayer concrete?
Answer: It will cause a compilation error.

Que 10:
final class Device {
    abstract void powerOn();
}

Question: What is wrong with this code?
Answer: A final class cannot have abstract methods because it cannot be extended.

Follow-up: How can we fix this?
Answer: Remove final or make the method concrete.

Que 11:
abstract class Tool {
    void use() {
        System.out.println("Using tool...");
    }
}


Question: Is this a valid abstract class?
Answer: Yes, an abstract class can have only concrete methods.

Follow-up: Why might we declare a class abstract even if it has no abstract methods?
Answer: To prevent direct instantiation.

Que 12:
interface Computer {
    default void boot() {
        System.out.println("Booting...");
    }
}

Question: Is this a valid interface?
Answer: Yes, an interface can have default methods.

Follow-up: How does a default method differ from an abstract method?
Answer: A default method has an implementation, while an abstract method does not.

Que 13:
abstract class Device {
    Device() {
        configure();
    }
    abstract void configure();
}
class Laptop extends Device {
    void configure() {
        System.out.println("Laptop configured");
    }
}
public class Test {
    public static void main(String[] args) {
        Laptop l = new Laptop();
    }
}

Question: Will this code work?
Answer: Yes, but calling an abstract method in a constructor can lead to issues if the method depends on subclass initialization.

Follow-up: What is the potential risk in this approach?
Answer: The abstract method might access uninitialized fields of the subclass.

Que 14:
abstract class Vehicle {
    final void start() {
        System.out.println("Starting...");
    }
}
class Bike extends Vehicle {
    void start() {
        System.out.println("Bike starting...");
    }
}


Question: Why does this code fail?
Answer: The start() method in Vehicle is final, so it cannot be overridden.

Follow-up: How should we fix it?
Answer: Remove final from start().

Que 15:
abstract class Gadget {
    abstract void turnOn();
    abstract void turnOff();
}

class Smartphone extends Gadget {
    void turnOn() {
        System.out.println("Smartphone turning on");
    }
}


Question: What is wrong with this code?
Answer: The turnOff() method is not implemented.

Follow-up: How can we fix this?
Answer: Implement the turnOff() method or declare Smartphone as abstract.

================================================================================================

OUTPUT QUESTIONS:
ENCAPSULATION:

Que 1:
class Person {
    private String name = "Alice";

    public String getName() {
        return name;
    }
}

public class Test {
    public static void main(String[] args) {
        Person p = new Person();
        System.out.println(p.getName());
    }
}

Question: What will be the output?
Answer: Alice

Follow-up: Why can't we access name directly in main?
Answer: Because name is private and only accessible through the getter.

Que 2:
class Car {
    private int speed;
    
    public int getSpeed() {
        return speed;
    }
}

public class Test {
    public static void main(String[] args) {
        Car c = new Car();
        System.out.println(c.getSpeed());
    }
}

Question: What will be the output?
Answer: 0 (default value for an int)

Follow-up: What would be the default value if speed were of type double?
Answer: 0.0

Que 3:
class BankAccount {
    private double balance = 1000.50;
    
    public void setBalance(double amount) {
        balance = amount;
    }

    public double getBalance() {
        return balance;
    }
}

public class Test {
    public static void main(String[] args) {
        BankAccount acc = new BankAccount();
        acc.setBalance(500.75);
        System.out.println(acc.getBalance());
    }
}

Question: What will be the output?
Answer: 500.75

Follow-up: What happens if we remove the setBalance method?
Answer: The balance remains unchanged (1000.50).


Que 4:
class Student {
    private int age;

    public void setAge(int a) {
        if (a > 0) {
            age = a;
        }
    }

    public int getAge() {
        return age;
    }
}

public class Test {
    public static void main(String[] args) {
        Student s = new Student();
        s.setAge(-5);
        System.out.println(s.getAge());
    }
}

Question: What will be the output?
Answer: 0 (default int value, as setAge(-5) does not update age)

Follow-up: How can we ensure that age is always set to a positive value?
Answer: By handling invalid input in the setter (e.g., throwing an exception or setting a default positive value).

Que 5:
class Employee {
    private String name;
    
    Employee(String n) {
        name = n;
    }

    public String getName() {
        return name;
    }
}

public class Test {
    public static void main(String[] args) {
        Employee e = new Employee("John");
        System.out.println(e.getName());
    }
}

Question: What will be the output?
Answer: John

Follow-up: What happens if we do not provide a constructor?
Answer: The default constructor will be used, and name will remain null.

Que 6:
class Data {
    private int value = 42;
}

public class Test {
    public static void main(String[] args) {
        Data d = new Data();
        // System.out.println(d.value); // Uncomment this line
    }
}


Question: What will happen if we uncomment System.out.println(d.value);?
Answer: Compilation error (value is private and inaccessible).

Follow-up: How can we access value?
Answer: By adding a getValue() method.


Que 7:
class Book {
    private String title = "Java Basics";

    public void printTitle() {
        System.out.println(title);
    }
}

public class Test {
    public static void main(String[] args) {
        Book b = new Book();
        b.printTitle();
    }
}


Question: What will be the output?
Answer: Java Basics

Follow-up: Can we modify title directly in main?
Answer: No, because it is private.

Que 8:
class User {
    private String username;

    public void setUsername(String username) {
        this.username = username;
    }

    public String getUsername() {
        return username;
    }
}

public class Test {
    public static void main(String[] args) {
        User u = new User();
        u.setUsername("Admin");
        System.out.println(u.getUsername());
    }
}

Question: What will be the output?
Answer: Admin

Follow-up: What happens if we remove this. in setUsername?
Answer: The method parameter will shadow the instance variable, and username will remain null.

Que 9:
class Product {
    private double price = 99.99;

    public double getPrice() {
        return price;
    }
}

public class Test {
    public static void main(String[] args) {
        Product p1 = new Product();
        Product p2 = new Product();
        System.out.println(p1.getPrice() + p2.getPrice());
    }
}

Question: What will be the output?
Answer: 199.98

Follow-up: Why do both objects have the same price value?
Answer: Because each instance initializes price to 99.99.

Que 10:
class ImmutableData {
    private final int id;

    ImmutableData(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }
}

public class Test {
    public static void main(String[] args) {
        ImmutableData obj = new ImmutableData(10);
        System.out.println(obj.getId());
    }
}


Question: What will be the output?
Answer: 10

Follow-up: Can we modify id after object creation?
Answer: No, because it is final and can only be set in the constructor.

Que 11:
class Counter {
    private int count = 5;

    public void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}

public class Test {
    public static void main(String[] args) {
        Counter c = new Counter();
        c.increment();
        System.out.println(c.getCount());
    }
}

Question: What will be the output?
Answer: 6

Follow-up: What happens if we call increment() twice before printing?
Answer: The output will be 7 since count increases by 1 each time.

Que 12:
class Animal {
    private String type = "Mammal";

    public String getType() {
        return type;
    }
}

public class Test {
    public static void main(String[] args) {
        Animal a = new Animal();
        // System.out.println(a.type); // Uncomment this line
        System.out.println(a.getType());
    }
}

Question: What will be the output?
Answer: Mammal

Follow-up: What happens if we uncomment System.out.println(a.type);?
Answer: A compilation error occurs because type is private.

Que 13:
class Account {
    private double balance = 1000;

    public double getBalance() {
        return balance;
    }
}

public class Test {
    public static void main(String[] args) {
        Account acc = new Account();
        // acc.balance = 500; // Uncomment this line
        System.out.println(acc.getBalance());
    }
}

Question: What will be the output?
Answer: 1000

Follow-up: How can we allow controlled modification of balance?
Answer: By adding a setter method (e.g., setBalance(double amount)).

Que 14:
class Laptop {
    private String brand;

    Laptop(String b) {
        brand = b;
    }

    public String getBrand() {
        return brand;
    }
}

public class Test {
    public static void main(String[] args) {
        Laptop l = new Laptop("Dell");
        System.out.println(l.getBrand());
    }
}


Question: What will be the output?
Answer: Dell

Follow-up: What happens if we do not pass "Dell" while creating the object?
Answer: A compilation error occurs because the constructor requires a parameter.

Que 15:
class Student {
    private String name;

    Student(String n) {
        name = n;
    }

    public String getName() {
        return name;
    }
}

public class Test {
    public static void main(String[] args) {
        Student s1 = new Student("Alice");
        Student s2 = new Student("Bob");
        System.out.println(s1.getName() + " & " + s2.getName());
    }
}

Question: What will be the output?
Answer: Alice & Bob

Follow-up: How can we modify name after object creation?
Answer: By adding a setter method (e.g., setName(String name)).


ABSTRACTION:

Que 1:
abstract class Shape {
    abstract void draw();
}

class Circle extends Shape {
    void draw() {
        System.out.println("Drawing Circle");
    }
}

public class Test {
    public static void main(String[] args) {
        Shape s = new Circle();
        s.draw();
    }
}

Question: What will be the output?
Answer: Drawing Circle

Follow-up: What happens if we try to instantiate Shape directly?
Answer: A compilation error occurs because abstract classes cannot be instantiated.

Que 2:
abstract class Animal {
    abstract void makeSound();

    void sleep() {
        System.out.println("Sleeping...");
    }
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("Barking");
    }
}

public class Test {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.makeSound();
        d.sleep();
    }
}

Question: What will be the output?
Answer:
Barking  
Sleeping...

Follow-up: Why is sleep() not overridden in Dog?
Answer: Because it is a concrete (non-abstract) method, and Dog inherits it as is.

Que 3:
abstract class Vehicle {
    void type() {
        System.out.println("Vehicle type");
    }
}

class Car extends Vehicle {
}

public class Test {
    public static void main(String[] args) {
        Car c = new Car();
        c.type();
    }
}

Question: What will be the output?
Answer: Vehicle type

Follow-up: Is it necessary for an abstract class to have an abstract method?
Answer: No, an abstract class can have only concrete methods.

Que 4:
abstract class Game {
    abstract void play();
}

class Cricket extends Game {
    void play() {
        System.out.println("Playing Cricket");
    }
}

class Football extends Game {
    void play() {
        System.out.println("Playing Football");
    }
}

public class Test {
    public static void main(String[] args) {
        Game g1 = new Cricket();
        Game g2 = new Football();
        g1.play();
        g2.play();
    }
}

Question: What will be the output?
Answer:
Playing Cricket  
Playing Football

Follow-up: What would happen if Cricket did not override play()?
Answer: A compilation error occurs because an abstract method must be implemented in the subclass.

Que 5:
abstract class Device {
    Device() {
        System.out.println("Device Created");
    }
    abstract void start();
}

class Laptop extends Device {
    void start() {
        System.out.println("Laptop Starting...");
    }
}

public class Test {
    public static void main(String[] args) {
        Laptop l = new Laptop();
        l.start();
    }
}

Question: What will be the output?
Answer:
Device Created  
Laptop Starting...

Que 6:
abstract class Instrument {
    abstract void play();
}

class Piano extends Instrument {
    void play() {
        System.out.println("Playing Piano");
    }
}

public class Test {
    public static void main(String[] args) {
        Instrument i = new Piano();
        i.play();
    }
}

Question: What will be the output?
Answer: Playing Piano

Follow-up: Can we create an object of Instrument?
Answer: No, because it is an abstract class.

Que 7:
interface Animal {
    void sound();
}

class Cat implements Animal {
    public void sound() {
        System.out.println("Meow");
    }
}

public class Test {
    public static void main(String[] args) {
        Animal a = new Cat();
        a.sound();
    }
}

Question: What will be the output?
Answer: Meow

Follow-up: Why does sound() need to be public in Cat?
Answer: Because interface methods are implicitly public, and overriding methods cannot have a more restrictive access level.

Que 8:
abstract class Parent {
    abstract void display();
}

class Child extends Parent {
    void display() {
        System.out.println("Child Display");
    }
}

public class Test {
    public static void main(String[] args) {
        Parent p = new Child();
        p.display();
    }
}


Question: What will be the output?
Answer: Child Display

Follow-up: Can display() be declared private in Parent?
Answer: No, because abstract methods must be public or protected to be overridden.

Que 9:
abstract class Employee {
    abstract void work();
}

class Manager extends Employee {
    void work() {
        System.out.println("Managing Team");
    }
}

public class Test {
    public static void main(String[] args) {
        Employee e = new Manager();
        e.work();
    }
}

Question: What will be the output?
Answer: Managing Team

Follow-up: What happens if Manager does not override work()?
Answer: A compilation error occurs because work() is abstract and must be implemented.

Que 10:
abstract class Printer {
    static void printMessage() {
        System.out.println("Printing...");
    }
}

public class Test {
    public static void main(String[] args) {
        Printer.printMessage();
    }
}

Question: What will be the output?
Answer: Printing...

Follow-up: Why can we call printMessage() without an object?
Answer: Because it is a static method and belongs to the class, not an instance.

Que 11:
abstract class Bird {
    abstract void fly();

    void eat() {
        System.out.println("Bird is eating");
    }
}

class Sparrow extends Bird {
    void fly() {
        System.out.println("Sparrow is flying");
    }
}

public class Test {
    public static void main(String[] args) {
        Sparrow s = new Sparrow();
        s.fly();
        s.eat();
    }
}

Question: What will be the output?
Answer:
Sparrow is flying  
Bird is eating

Follow-up: What happens if we remove fly() from Sparrow?
Answer: A compilation error occurs because fly() is abstract and must be implemented.

Que 12:
abstract class Bank {
    abstract int getInterestRate();

    void displayRate() {
        System.out.println("Interest Rate: " + getInterestRate() + "%");
    }
}

class SBI extends Bank {
    int getInterestRate() {
        return 5;
    }
}

public class Test {
    public static void main(String[] args) {
        SBI s = new SBI();
        s.displayRate();
    }
}

Question: What will be the output?
Answer: Interest Rate: 5%

Follow-up: What will happen if we create another subclass ICICI with getInterestRate() returning 7 and call displayRate() on an ICICI object?
Answer: The output will be Interest Rate: 7%.

Que 13:
abstract class Vehicle {
    Vehicle() {
        System.out.println("Vehicle Created");
    }

    Vehicle(String type) {
        System.out.println(type + " Created");
    }

    abstract void run();
}

class Bike extends Vehicle {
    Bike() {
        super("Bike");
    }

    void run() {
        System.out.println("Bike is running");
    }
}

public class Test {
    public static void main(String[] args) {
        Bike b = new Bike();
        b.run();
    }
}

Question: What will be the output?
Answer:
Bike Created  
Bike is running

Follow-up: What happens if super("Bike"); is removed?
Answer: The default constructor of Vehicle will be called instead, and the output will change to:
Vehicle Created  
Bike is running

Que 14:
abstract class Appliance {
    final void powerOn() {
        System.out.println("Powering On...");
    }

    abstract void operate();
}

class WashingMachine extends Appliance {
    void operate() {
        System.out.println("Washing Clothes");
    }
}

public class Test {
    public static void main(String[] args) {
        WashingMachine wm = new WashingMachine();
        wm.powerOn();
        wm.operate();
    }
}

Question: What will be the output?
Answer:
Powering On...  
Washing Clothes

Follow-up: Can we override powerOn() in WashingMachine?
Answer: No, because it is declared final in the abstract class.

Que 15:
interface Animal {
    void makeSound();
}

abstract class Mammal implements Animal {
    void sleep() {
        System.out.println("Sleeping...");
    }
}

class Dog extends Mammal {
    public void makeSound() {
        System.out.println("Barking");
    }
}

public class Test {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.makeSound();
        d.sleep();
    }
}

Question: What will be the output?
Answer:
Barking  
Sleeping...

Follow-up: Why does Mammal not implement makeSound()?
Answer: Because it is an abstract class and can leave method implementation to subclasses.

==================================================================================================

PROBLEM CODE:
ENCAPSULATION:

Que 1:
class Student {
    private int rollNo;
}

public class Test {
    public static void main(String[] args) {
        Student s = new Student();
        s.rollNo = 101;
    }
}

Question: What is the error in this code?
Answer: rollNo is private and cannot be accessed directly.

Follow-up: How can we modify this code to access rollNo?
Answer: Use getter and setter methods.

Que 2:
class Employee {
    private String name;
    private double salary;
    
    void setSalary(double s) {
        salary = s;
    }
}

public class Test {
    public static void main(String[] args) {
        Employee e = new Employee();
        e.setSalary(50000);
        System.out.println(e.salary);
    }
}

Question: Why does this code fail to compile?
Answer: salary is private and cannot be accessed directly.

Follow-up: How do we fix this issue?
Answer: Add a getSalary() method to retrieve the value.

Que 3:
class Singleton {
    private static Singleton instance;
    private Singleton() {}

    static Singleton getInstance() {
        return new Singleton();
    }
}

public class Test {
    public static void main(String[] args) {
        Singleton s1 = new Singleton();
    }
}

Question: Why does this code give an error?
Answer: The constructor of Singleton is private, so it cannot be instantiated directly.

Follow-up: How should an object of Singleton be created?
Answer: Use Singleton.getInstance(); instead of new Singleton();.

Que 4:
class Car {
    private String model;
    private int speed;
    
    void setModel(String model) {
        model = model;
    }
    
    String getModel() {
        return model;
    }
}

public class Test {
    public static void main(String[] args) {
        Car c = new Car();
        c.setModel("Tesla");
        System.out.println(c.getModel());
    }
}

Question: Why does System.out.println(c.getModel()); print null instead of "Tesla"?
Answer: The setModel() method has a scope issue—it assigns model = model; instead of this.model = model;.

Follow-up: How can we correct this mistake?
Answer: Change model = model; to this.model = model; in setModel().

Que 5:
class BankAccount {
    private final double balance;
    
    BankAccount(double balance) {
        this.balance = balance;
    }
    
    void setBalance(double balance) {
        this.balance = balance;
    }
}

Question: Why does this code fail to compile?
Answer: balance is final and cannot be reassigned in setBalance().

Follow-up: How should we modify balance safely?
Answer: Use a method like deposit() or withdraw() instead of setBalance().

Que 6:
class Laptop {
    private String brand;
    
    Laptop(String brand) {
        this.brand = brand;
    }
}

public class Test {
    public static void main(String[] args) {
        Laptop l = new Laptop("Dell");
        System.out.println(l.brand);
    }
}

Question: Why does this code produce an error?
Answer: brand is private and cannot be accessed directly.

Follow-up: How can we retrieve the value of brand?
Answer: Add a public getBrand() method.

Que 7:
class Person {
    private int age;
}

public class Test {
    public static void main(String[] args) {
        Person p = new Person();
        p.age = 25;
    }
}

Question: What is the issue with this code?
Answer: age is private and cannot be accessed directly.

Follow-up: How can we modify age properly?
Answer: Use a setter method like setAge(int age).

Que 8:
class Address {
    private String city;
    
    Address(String city) {
        this.city = city;
    }
    
    String getCity() {
        return city;
    }
}

class Employee {
    private Address address;
    
    Employee(Address address) {
        this.address = address;
    }
    
    Address getAddress() {
        return address;
    }
}

public class Test {
    public static void main(String[] args) {
        Address addr = new Address("New York");
        Employee e = new Employee(addr);
        e.getAddress().city = "Los Angeles";
        System.out.println(e.getAddress().getCity());
    }
}

Question: What is wrong with this encapsulation approach?
Answer: The private field city is indirectly modified through the returned Address object.

Follow-up: How can we prevent modification of city?
Answer: Return a copy of Address in getAddress() instead of the original object.

Que 9:
class Parent {
    private String secret = "Hidden";

    public String getSecret() {
        return secret;
    }
}

class Child extends Parent {
    public String getSecret() {
        return "Revealed";
    }
}

public class Test {
    public static void main(String[] args) {
        Parent p = new Child();
        System.out.println(p.getSecret());
    }
}


Question: What will this code output?
Answer: Hidden

Follow-up: Why does Child's getSecret() not override Parent's method?
Answer: Because secret is private and Child does not inherit it.

Que 10:
class Book {
    public String title;
}

public class Test {
    public static void main(String[] args) {
        Book b = new Book();
        b.title = "Encapsulation in Java";
        System.out.println(b.title);
    }
}


Question: What is the issue with this class?
Answer: title is public, breaking encapsulation.

Follow-up: How can we make this properly encapsulated?
Answer: Declare title as private and use getter and setter methods.

Que 11:
class Product {
    private double price;
    
    public double getPrice() {
        return price;
    }
}

public class Test {
    public static void main(String[] args) {
        Product p = new Product();
        p.price = 299.99;
        System.out.println(p.getPrice());
    }
}

Question: Why does this code fail to compile?
Answer: price is private and cannot be assigned directly.

Follow-up: How can we modify the price of the product?
Answer: Add a setter method:
public void setPrice(double price) {
    this.price = price;
}

Que 12:
class Bank {
    private double balance;
    
    Bank(double balance) {
        this.balance = balance;
    }
}

public class Test {
    public static void main(String[] args) {
        Bank acc = new Bank(1000);
        acc.balance += 500;
        System.out.println(acc.balance);
    }
}

Question: Why does this code fail to compile?
Answer: The balance variable is private and cannot be accessed directly.

Follow-up: How should we modify the balance correctly?
Answer: Use deposit() and withdraw() methods instead of direct access.

class User {
    private String username;
    
    User(String username) {
        this.username = username;
    }
    
    public String getUsername() {
        return username;
    }
}

public class Test {
    public static void main(String[] args) {
        User u = new User("JohnDoe");
        u.username = "JaneDoe";
        System.out.println(u.getUsername());
    }
}

Question: Why does this code cause a compilation error?
Answer: username is private and cannot be accessed directly.

Follow-up: How can we allow modification of username?
Answer: Add a setter method:
public void setUsername(String username) {
    this.username = username;
}

Que 14:
class Game {
    private final String name;
    
    Game(String name) {
        this.name = name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}

Question: Why does this code fail to compile?
Answer: name is final, meaning it cannot be reassigned in setName().

Follow-up: How can we allow the name to be set without breaking encapsulation?
Answer: Remove the final keyword or use a constructor-only approach.

Que 15:
class Address {
    private String city;
    
    Address(String city) {
        this.city = city;
    }
    
    public String getCity() {
        return city;
    }
}

class Student {
    private Address address;
    
    Student(Address address) {
        this.address = address;
    }
    
    public Address getAddress() {
        return address;
    }
}

public class Test {
    public static void main(String[] args) {
        Address addr = new Address("New York");
        Student s = new Student(addr);
        s.getAddress().city = "Los Angeles";
        System.out.println(s.getAddress().getCity());
    }
}

Question: Why does this code break encapsulation?
Answer: The private field city is indirectly modified through the returned Address object.

Follow-up: How can we prevent modification of city?
Answer: Return a copy of Address in getAddress() instead of the original object:
public Address getAddress() {
    return new Address(this.address.getCity());
}

ABSTRACTION:

Que 1:
abstract class Animal {
    abstract void makeSound();
}

public class Test {
    public static void main(String[] args) {
        Animal a = new Animal();
        a.makeSound();
    }
}

Question: Why does this code fail to compile?
Answer: Abstract classes cannot be instantiated directly.

Follow-up: How can we correct this code?
Answer: Create a subclass of Animal and instantiate that instead:
class Dog extends Animal {
    void makeSound() {
        System.out.println("Bark!");
    }
}

public class Test {
    public static void main(String[] args) {
        Animal a = new Dog();
        a.makeSound();
    }
}

Que 2:
abstract class Vehicle {
    void start() {
        System.out.println("Vehicle starting...");
    }
}

public class Test {
    public static void main(String[] args) {
        Vehicle v = new Vehicle();
        v.start();
    }
}

Question: Why does this code fail to compile?
Answer: Abstract classes cannot be instantiated, even if they don’t have abstract methods.

Follow-up: How can we use Vehicle in a valid way?
Answer: Extend Vehicle with a concrete class:
class Car extends Vehicle {}

public class Test {
    public static void main(String[] args) {
        Vehicle v = new Car();
        v.start();
    }
}

Que 3:
abstract class Shape {
    abstract void draw();
}

class Circle extends Shape {}

public class Test {
    public static void main(String[] args) {
        Shape s = new Circle();
        s.draw();
    }
}

Question: Why does this code fail to compile?
Answer: The class Circle must implement the abstract method draw() or be declared abstract.

Follow-up: How can we fix this issue?
Answer: Implement the draw() method in Circle:
class Circle extends Shape {
    void draw() {
        System.out.println("Drawing a circle");
    }
}


Que 4:
abstract class Computer {
    final void turnOn() {
        System.out.println("Computer is turning on...");
    }
    
    abstract void runProgram();
}

class Laptop extends Computer {
    void turnOn() {
        System.out.println("Laptop is turning on...");
    }
    
    void runProgram() {
        System.out.println("Running program on laptop...");
    }
}

public class Test {
    public static void main(String[] args) {
        Computer c = new Laptop();
        c.turnOn();
    }
}

Question: Why does this code fail to compile?
Answer: turnOn() is declared final in Computer, so it cannot be overridden in Laptop.

Follow-up: How should we modify the Laptop class?
Answer: Remove the turnOn() method from Laptop, as it should inherit the one from Computer.

Que 5:
abstract class Device {
    Device() {
        System.out.println("Device initialized");
    }
    
    abstract void operate();
}

class Phone extends Device {
    void operate() {
        System.out.println("Phone is operating");
    }
}

public class Test {
    public static void main(String[] args) {
        Device d = new Device();
    }
}

Question: Why does this code fail to compile?
Answer: Abstract classes cannot be instantiated directly.

Follow-up: What happens when we create a Phone object?
Answer: The constructor of Device is called first, then Phone’s operate() method is available.

Que 6:
abstract class Gadget {
    Gadget() {
        System.out.println("Gadget created");
    }
}

public class Test {
    public static void main(String[] args) {
        Gadget g = new Gadget();
    }
}

Question: Why does this code fail to compile?
Answer: Abstract classes cannot be instantiated directly.

Follow-up: How can we use the Gadget class correctly?
Answer: Create a subclass and instantiate that:
class Phone extends Gadget {}

public class Test {
    public static void main(String[] args) {
        Gadget g = new Phone();
    }
}

Que 7:
abstract class Machine {
    Machine() {
        start();
    }

    abstract void start();
}

class Car extends Machine {
    void start() {
        System.out.println("Car starting...");
    }
}

public class Test {
    public static void main(String[] args) {
        Machine m = new Car();
    }
}

Question: Will this code run correctly? If so, what will be the output?
Answer: Yes, it will run. The output will be:
Car starting...

Follow-up: Why is the start() method called inside the Machine constructor?
Answer: Because the subclass (Car) has overridden start(), it executes during the Machine constructor call.

Que 8:
class Animal {
    abstract void makeSound();
}

public class Test {
    public static void main(String[] args) {
        Animal a = new Animal();
    }
}

Question: Why does this code fail to compile?
Answer: A class containing an abstract method must also be abstract.

Follow-up: How can we fix this?
Answer: Declare Animal as an abstract class:
abstract class Animal {
    abstract void makeSound();
}

Que 9:
interface Playable {
    void play();
}

abstract class Instrument implements Playable {}

public class Test {
    public static void main(String[] args) {
        Instrument i = new Instrument();
    }
}

Question: Why does this code fail to compile?
Answer: Abstract classes are not required to implement interface methods, but they cannot be instantiated.

Follow-up: How can we use Instrument correctly?
Answer: Create a subclass that implements play():
class Guitar extends Instrument {
    public void play() {
        System.out.println("Playing guitar...");
    }
}


Que 10:
abstract class Calculator {
    static int add(int a, int b) {
        return a + b;
    }
}

public class Test {
    public static void main(String[] args) {
        Calculator c = new Calculator();
        System.out.println(c.add(5, 3));
    }
}

Question: Why does this code fail to compile?
Answer: Abstract classes cannot be instantiated.

Follow-up: How can we access add() correctly?
Answer: Use Calculator.add(5, 3); instead of creating an instance.

Que 11:
abstract class Bird {
    abstract void fly();
}

class Penguin extends Bird {
}

public class Test {
    public static void main(String[] args) {
        Bird b = new Penguin();
        b.fly();
    }
}

Question: Why does this code fail to compile?
Answer: Penguin does not implement fly(), so it must be declared abstract.

Follow-up: How can we fix this?
Answer: Implement fly() in Penguin or declare Penguin as abstract.

Que 12:
abstract class Animal {
    abstract void eat();
}

final class Dog extends Animal {}

public class Test {
    public static void main(String[] args) {
        Dog d = new Dog();
    }
}

Question: Why does this code fail to compile?
Answer: Dog must implement eat() before it can be instantiated.

Follow-up: How can we fix this?
Answer: Implement eat() in Dog:

final class Dog extends Animal {
    void eat() {
        System.out.println("Dog is eating...");
    }
}


Que 13:
abstract class Vehicle {
    abstract void start();
}

abstract class Car extends Vehicle {}

public class Test {
    public static void main(String[] args) {
        Vehicle v = new Car();
    }
}

Question: Why does this code fail to compile?
Answer: Car is still abstract and cannot be instantiated.

Follow-up: How can we use Car correctly?
Answer: Create a concrete subclass:
class Sedan extends Car {
    void start() {
        System.out.println("Sedan is starting...");
    }
}


Que 14:
abstract class Device {
    abstract void run() {
        System.out.println("Device is running");
    }
}

Question: Why does this code fail to compile?
Answer: Abstract methods cannot have a body.

Follow-up: How can we correct this?
Answer: Remove the body or make it a concrete method.

Que 15:
abstract class A {
    abstract void methodA();
}

abstract class B {
    abstract void methodB();
}

public class Test extends A, B {
    void methodA() {
        System.out.println("Method A");
    }
    
    void methodB() {
        System.out.println("Method B");
    }
}

Question: Why does this code fail to compile?
Answer: Java does not support multiple inheritance with classes.

Follow-up: How can we achieve similar functionality?
Answer: Use interfaces instead of abstract classes:
interface A {
    void methodA();
}

interface B {
    void methodB();
}

class Test implements A, B {
    public void methodA() { System.out.println("Method A"); }
    public void methodB() { System.out.println("Method B"); }
}

========================================================================================

MCQs
ENCAPSULATION:

What is Encapsulation in Java?
a) Hiding the implementation details and only exposing methods
b) Inheritance in Java
c) A type of polymorphism
d) Using static methods
Answer: a) Hiding the implementation details and only exposing methods

Which access modifier is commonly used to achieve encapsulation?
a) private
b) public
c) protected
d) default
Answer: a) private

How can we access private variables of a class from outside?
a) Using getter and setter methods
b) Declaring them as public
c) Using constructors only
d) It is not possible
Answer: a) Using getter and setter methods

What is the primary goal of encapsulation?
a) Code optimization
b) Code security and maintainability
c) Faster execution
d) Making all variables public
Answer: b) Code security and maintainability

In encapsulation, variables of a class should be:
a) Public
b) Private
c) Protected
d) Static
Answer: b) Private

What happens if getter methods are not provided in an encapsulated class?
a) Data cannot be accessed outside the class
b) Compilation error
c) All variables will be accessible automatically
d) Program runs slowly
Answer: a) Data cannot be accessed outside the class

Encapsulation improves:
a) Security and reusability
b) Performance
c) Storage space
d) Code execution speed
Answer: a) Security and reusability

Which principle does Encapsulation belong to?
a) OOPS (Object-Oriented Programming)
b) Functional Programming
c) Procedural Programming
d) None of the above
Answer: a) OOPS (Object-Oriented Programming)

Encapsulation is also known as:
a) Data hiding
b) Inheritance
c) Polymorphism
d) Abstraction
Answer: a) Data hiding

In Java, encapsulation is implemented by using:
a) Private variables and public methods
b) Public variables and methods
c) Static classes
d) Interfaces
Answer: a) Private variables and public methods

Medium Level (21-40)
Can a class be fully encapsulated in Java?
a) Yes, by making all data members private and providing public methods
b) No, encapsulation is not possible in Java
c) Yes, by using only static methods
d) No, encapsulation requires public variables
Answer: a) Yes, by making all data members private and providing public methods

How can encapsulation improve code maintainability?
a) By allowing modification of internal data without affecting external code
b) By making all data public
c) By increasing execution speed
d) By removing constructors
Answer: a) By allowing modification of internal data without affecting external code

What is a common mistake when implementing encapsulation?
a) Exposing private fields directly
b) Using getter and setter methods
c) Making methods public
d) Using constructors
Answer: a) Exposing private fields directly

Which of the following is NOT an advantage of encapsulation?
a) Code maintainability
b) Code reusability
c) Better performance
d) Security
Answer: c) Better performance

Which keyword restricts access the most in Java?
a) public
b) protected
c) default
d) private
Answer: d) private

Encapsulation helps in:
a) Preventing direct access to object data
b) Increasing execution speed
c) Reducing memory usage
d) Allowing multiple inheritance
Answer: a) Preventing direct access to object data

What happens if a private variable does not have a setter method?
a) It becomes read-only
b) It becomes write-only
c) It cannot be accessed at all
d) The program crashes
Answer: a) It becomes read-only

Can a class have only setter methods and still be encapsulated?
a) Yes, but it will be write-only
b) No, encapsulation requires both getter and setter
c) Yes, it is always allowed
d) No, encapsulation requires all methods private
Answer: a) Yes, but it will be write-only

Which of the following is correct for encapsulation?
a) Encapsulation is achieved through private variables and public methods
b) Encapsulation can only be used in inheritance
c) Encapsulation is the same as abstraction
d) Encapsulation is not used in real applications
Answer: a) Encapsulation is achieved through private variables and public methods

What is the output of the following code?

java
Copy
Edit
class Test {
    private int value = 10;
    public int getValue() { return value; }
}
public class Main {
    public static void main(String args[]) {
        Test obj = new Test();
        System.out.println(obj.getValue());
    }
}
a) Compilation Error
b) 10
c) NullPointerException
d) Runtime Error
Answer: b) 10

Hard Level (41-50)
Can a final variable be changed through encapsulation?
a) No, final variables cannot be modified
b) Yes, using a setter method
c) Yes, using a constructor
d) No, unless reflection is used
Answer: a) No, final variables cannot be modified

Can we achieve encapsulation using an abstract class?
a) Yes
b) No
c) Only with interfaces
d) Only with static classes
Answer: a) Yes

How does encapsulation relate to loose coupling?
a) It reduces dependencies between classes
b) It increases dependencies
c) It makes all methods static
d) It does not affect coupling
Answer: a) It reduces dependencies between classes

Can encapsulation be broken using Java reflection?
a) Yes
b) No
c) Only in Java 8+
d) Only in interfaces
Answer: a) Yes

What is the effect of making a setter method private?
a) The variable becomes read-only
b) The variable becomes write-only
c) The variable cannot be accessed at all
d) Compilation error
Answer: a) The variable becomes read-only

Which statement is true about encapsulation in Java?
a) It only works with public variables
b) It protects the integrity of an object's data
c) It allows variables to be modified directly
d) It does not support polymorphism
Answer: b) It protects the integrity of an object's data

Can an encapsulated class have public variables?
a) No, all variables must be private
b) Yes, but it breaks encapsulation
c) No, Java does not allow public variables
d) Yes, it does not affect encapsulation
Answer: b) Yes, but it breaks encapsulation

How can encapsulation help in unit testing?
a) It allows modification of private data without affecting other classes
b) It makes all variables public for testing
c) It reduces method calls
d) It removes dependencies completely
Answer: a) It allows modification of private data without affecting other classes

Which OOP principle does encapsulation enforce the most?
a) Inheritance
b) Abstraction
c) Encapsulation
d) Polymorphism
Answer: c) Encapsulation

Which Java feature is closely related to encapsulation?
a) Static methods
b) Interfaces
c) Access modifiers
d) Switch statements
Answer: c) Access modifiers

What happens if both getter and setter methods are removed from an encapsulated class?
a) The class remains encapsulated but inaccessible
b) The class loses encapsulation
c) The variables become public automatically
d) Compilation error occurs
Answer: a) The class remains encapsulated but inaccessible

What happens when you provide only a getter method for a variable?
a) It becomes read-only
b) It becomes write-only
c) It cannot be accessed at all
d) It results in an error
Answer: a) It becomes read-only

Can encapsulation be applied to static variables?
a) Yes, with private static variables
b) No, static variables cannot be encapsulated
c) Yes, but only in abstract classes
d) No, static variables cannot have access modifiers
Answer: a) Yes, with private static variables

Which access modifier allows encapsulation while restricting access only within the same package?
a) private
b) public
c) protected
d) default (no modifier)
Answer: d) default (no modifier)

Why is encapsulation considered a good practice?
a) It enhances security by restricting access to data
b) It increases code size
c) It makes variables public
d) It slows down execution
Answer: a) It enhances security by restricting access to data

What happens if you define a class with all public fields?
a) Encapsulation is broken
b) The code runs faster
c) The program will not compile
d) The class becomes abstract
Answer: a) Encapsulation is broken

Which of the following access modifiers supports maximum encapsulation?
a) public
b) protected
c) private
d) default
Answer: c) private

Can we override getter and setter methods in a subclass?
a) Yes
b) No
c) Only if the superclass methods are final
d) Only if the subclass is abstract
Answer: a) Yes

Can encapsulation be used in multi-threaded applications?
a) Yes, it helps maintain data integrity
b) No, encapsulation is only for single-threaded programs
c) No, encapsulation prevents multiple threads from accessing data
d) Yes, but only with static variables
Answer: a) Yes, it helps maintain data integrity

Which of the following is true about encapsulation?
a) It hides data implementation details
b) It is the same as inheritance
c) It makes all methods static
d) It does not affect security
Answer: a) It hides data implementation details

Can a constructor access private variables directly inside a class?
a) Yes
b) No
c) Only if it's public
d) Only if it's static
Answer: a) Yes

Why is it recommended to use getter and setter methods instead of accessing fields directly?
a) It provides more control over data access
b) It increases memory usage
c) It speeds up execution
d) It makes all data public
Answer: a) It provides more control over data access

Can an encapsulated class be extended using inheritance?
a) Yes, but private members cannot be inherited
b) No, encapsulated classes cannot be inherited
c) Yes, but only using interfaces
d) No, encapsulation does not support inheritance
Answer: a) Yes, but private members cannot be inherited

What is the advantage of data hiding in encapsulation?
a) It protects the integrity of data
b) It speeds up execution
c) It allows direct variable modification
d) It makes all methods private
Answer: a) It protects the integrity of data

Can encapsulation be achieved using interfaces in Java?
a) No, interfaces cannot encapsulate data
b) Yes, by using private methods in interfaces (Java 9+)
c) Yes, by making variables public
d) No, encapsulation requires only abstract classes
Answer: b) Yes, by using private methods in interfaces (Java 9+)

If we remove all setter methods in an encapsulated class, what will happen?
a) The class becomes read-only
b) The class loses encapsulation
c) It generates a compilation error
d) The class becomes write-only
Answer: a) The class becomes read-only

How does encapsulation help in achieving modular programming?
a) It isolates data from external code changes
b) It removes dependencies from other classes
c) It allows multiple inheritance
d) It makes all classes static
Answer: a) It isolates data from external code changes

Can encapsulation be applied to methods in Java?
a) Yes, using access modifiers
b) No, only variables can be encapsulated
c) No, methods are always public
d) Yes, but only in final classes
Answer: a) Yes, using access modifiers

How can encapsulation improve security in Java applications?
a) By restricting direct access to sensitive data
b) By allowing modification of all fields
c) By making all fields public
d) By increasing execution time
Answer: a) By restricting direct access to sensitive data

What happens when you create getter methods without setter methods?
a) The variable becomes read-only
b) The variable becomes write-only
c) The variable cannot be accessed
d) The program crashes
Answer: a) The variable becomes read-only


ABSTRACTION:

What is abstraction in Java?
a) Hiding implementation details and showing only essential features
b) Hiding data using private variables
c) Making all methods static
d) Writing all methods in one class
Answer: a

Which keyword is used to define an abstract class?
a) abstract
b) interface
c) final
d) static
Answer: a

Can an abstract class have a constructor in Java?
a) Yes
b) No
c) Only if all methods are abstract
d) Only if there are no abstract methods
Answer: a

What must a class do if it extends an abstract class with an abstract method?
a) It must implement all abstract methods
b) It must be marked as abstract
c) It cannot extend the abstract class
d) It must override the constructor
Answer: a

What happens if an abstract method is not implemented in a subclass?
a) Compilation error
b) Runtime error
c) The program runs fine
d) The abstract method is ignored
Answer: a

Can we create an instance of an abstract class?
a) Yes
b) No
c) Only if it has a constructor
d) Only in a static method
Answer: b

What is the default modifier of methods inside an interface?
a) private
b) public
c) protected
d) default
Answer: b

How many abstract methods must an abstract class have?
a) At least one
b) Exactly one
c) Any number, including zero
d) Cannot have concrete methods
Answer: c

What is the primary use of abstraction in Java?
a) To increase performance
b) To hide implementation details and simplify code usage
c) To avoid inheritance
d) To make all methods static
Answer: b

Can an abstract class have final methods?
a) Yes
b) No
c) Only static methods can be final
d) Only private methods can be final
Answer: a

Medium Level MCQs
Which of the following is true about an abstract class?
a) It can contain abstract and concrete methods
b) It cannot have member variables
c) It must have only abstract methods
d) It cannot have a constructor
Answer: a

Can we declare an abstract method as static?
a) Yes
b) No
c) Only if it is private
d) Only if it is final
Answer: b

What is the purpose of an interface in Java?
a) To achieve multiple inheritance
b) To define a class
c) To provide method implementation
d) To allow instance creation
Answer: a

Can an interface have constructors?
a) Yes
b) No
c) Only if all methods are static
d) Only if it extends an abstract class
Answer: b

Can an abstract class be final?
a) Yes
b) No
c) Only if it has no abstract methods
d) Only if it implements an interface
Answer: b

Can an abstract class implement an interface?
a) Yes
b) No
c) Only if all methods are implemented
d) Only if the interface has only static methods
Answer: a

Which of the following is true about interfaces?
a) All methods are public by default
b) Interfaces can have constructors
c) Interfaces can have instance variables
d) Interfaces cannot extend other interfaces
Answer: a

Can an interface contain default methods?
a) Yes
b) No
c) Only if they are static
d) Only if they are final
Answer: a

Which of the following cannot be part of an interface?
a) static methods
b) final variables
c) private methods
d) instance variables
Answer: d

Which of the following statements about abstract classes is false?
a) An abstract class can extend another abstract class
b) An abstract class can implement multiple interfaces
c) An abstract class can be instantiated
d) An abstract class can have concrete methods
Answer: c

Hard Level MCQs
Can an interface extend multiple interfaces?
a) Yes
b) No
c) Only if all interfaces are empty
d) Only if no abstract classes are involved
Answer: a

Can an interface extend an abstract class?
a) Yes
b) No
c) Only if the abstract class has only static methods
d) Only if the interface is marked as abstract
Answer: b

What is the main difference between an abstract class and an interface?
a) Abstract classes can have constructors, interfaces cannot
b) Interfaces can have instance variables, abstract classes cannot
c) Abstract classes cannot have concrete methods
d) Interfaces can be instantiated
Answer: a

Can a class implement multiple interfaces?
a) Yes
b) No
c) Only if they have the same methods
d) Only if all methods are private
Answer: a

Can an abstract class have private abstract methods?
a) Yes
b) No
c) Only if they are static
d) Only if they are final
Answer: b

Can an interface method be protected?
a) Yes
b) No
c) Only if it is static
d) Only if it is abstract
Answer: b

What is the default access modifier for an abstract class?
a) private
b) public
c) default (package-private)
d) protected
Answer: c

Can a class be both abstract and final?
a) Yes
b) No
c) Only if all methods are static
d) Only if it has no constructor
Answer: b

What happens if an abstract class has only concrete methods?
a) It compiles successfully
b) It causes a compilation error
c) It must be marked as final
d) It cannot extend another class
Answer: a

Which of the following statements is true?
a) An interface can have final methods
b) A class can extend multiple abstract classes
c) An abstract class can have a constructor
d) A private method can be abstract
Answer: c

Which of the following is true about abstract classes?
a) Abstract classes cannot have static methods
b) Abstract classes can contain both abstract and non-abstract methods
c) Abstract classes cannot extend another class
d) Abstract classes must override all parent class methods
Answer: b

What is the main purpose of an abstract class?
a) To prevent object creation
b) To define common behavior for subclasses
c) To enforce strict data hiding
d) To allow multiple inheritance
Answer: b

How many interfaces can a class implement?
a) One
b) Multiple
c) Zero
d) Only abstract classes can implement interfaces
Answer: b

What happens if an abstract class does not implement all interface methods?
a) It must be declared abstract
b) It causes a compilation error
c) It is converted into a concrete class
d) It must declare those methods as final
Answer: a

Can an interface have variables?
a) Yes, but they must be static and final
b) No, interfaces cannot have variables
c) Only protected variables are allowed
d) Yes, but only private variables are allowed
Answer: a

What will happen if we try to create an object of an abstract class?
a) Compilation error
b) Runtime error
c) Object is created successfully
d) The program executes but the object remains null
Answer: a

Can we declare an abstract method as synchronized?
a) Yes
b) No
c) Only if it is inside an interface
d) Only if it is final
Answer: b

What happens when a class implements two interfaces with the same default method?
a) Compilation error
b) The class must override the method
c) The method from the first implemented interface is used
d) Java automatically resolves the conflict
Answer: b

What is the key benefit of interfaces in Java?
a) They improve performance
b) They allow multiple inheritance
c) They prevent object creation
d) They allow private constructors
Answer: b

Which of the following statements about abstract classes is false?
a) An abstract class can have constructors
b) An abstract class can implement an interface
c) An abstract class can be instantiated using new keyword
d) An abstract class can have concrete methods
Answer: c

Can an abstract class have instance variables?
a) Yes
b) No
c) Only if they are final
d) Only if they are static
Answer: a

What happens if a concrete class extends an abstract class without implementing all abstract methods?
a) Compilation error
b) Runtime error
c) The abstract methods are ignored
d) The class becomes abstract
Answer: a

Can an interface implement another interface?
a) Yes
b) No
c) Only if both interfaces are abstract
d) Only if the subclass is marked final
Answer: a

What is the default access level of an abstract method?
a) public
b) private
c) protected
d) default (package-private)
Answer: a

Which of the following statements about interfaces is true?
a) Interfaces can have constructors
b) Interfaces cannot have static methods
c) Interfaces can extend multiple interfaces
d) Interfaces cannot have any method implementations
Answer: c

Can we declare an abstract class as final?
a) Yes
b) No
c) Only if it has no abstract methods
d) Only if it has a static block
Answer: b

What is the correct way to define an abstract method in an abstract class?
a) abstract void show() { }
b) void show() { }
c) abstract void show();
d) void abstract show();
Answer: c

Can an interface contain private methods?
a) Yes, starting from Java 9
b) No, interfaces cannot have private methods
c) Only if they are static
d) Only if they are abstract
Answer: a

What will happen if a concrete class implements an interface but does not define all of its methods?
a) Compilation error
b) Runtime error
c) The interface methods are ignored
d) Java automatically provides implementations
Answer: a

Can an abstract class implement an interface without implementing all its methods?
a) Yes, but it must remain abstract
b) No, it must implement all methods
c) Only if it has a constructor
d) Only if it extends another class
Answer: a

What happens if we remove the abstract keyword from an abstract method?
a) Compilation error
b) The method is treated as concrete
c) The method remains abstract
d) The method is converted to final
Answer: a

Can an interface have an abstract method?
a) Yes, all non-default methods in an interface are implicitly abstract
b) No, interfaces cannot have abstract methods
c) Only if it extends another interface
d) Only if the method is static
Answer: a

What is the main advantage of using abstract classes over interfaces?
a) Abstract classes can have implemented methods
b) Interfaces allow multiple inheritance
c) Abstract classes execute faster
d) Abstract classes allow private variables
Answer: a

Which statement is true about an interface method with a default implementation?
a) It must be overridden
b) It can be called using an instance of a class implementing the interface
c) It cannot have any method body
d) It must be marked as static
Answer: b

Can we declare a method inside an interface with a body?
a) Yes, if it is default or static
b) No, interfaces cannot have method bodies
c) Only if the method is private
d) Only if it is protected
Answer: a


============================================================================================================================================


LEETCODE QUETIONS:

Que1:
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

Implement the MinStack class:

MinStack() initializes the stack object.
void push(int val) pushes the element val onto the stack.
void pop() removes the element on the top of the stack.
int top() gets the top element of the stack.
int getMin() retrieves the minimum element in the stack.
You must implement a solution with O(1) time complexity for each function.

Example 1:

Input
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

Output
[null,null,null,null,-3,null,0,-2]


Solution:
class MinStack {
    private Stack<Integer> stack;
    private Stack<Integer> minStack;

    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }

    public void push(int val) {
        stack.push(val);
        if (minStack.isEmpty() || val <= minStack.peek()) {
            minStack.push(val);
        }
    }

    public void pop() {
        if (stack.isEmpty()) return;
        if (stack.pop().equals(minStack.peek())) {
            minStack.pop();
        }
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}


Que2:
Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):

BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.
boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.
int next() Moves the pointer to the right, then returns the number at the pointer.
Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.

You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.

 

Example 1:


Input
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
Output
[null, 3, 7, true, 9, true, 15, true, 20, false]

Explanation
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // return 3
bSTIterator.next();    // return 7
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 9
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 15
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 20
bSTIterator.hasNext(); // return False
 

Solution:
public class BSTIterator {
    private Stack<TreeNode> stack = new Stack<TreeNode>();
    
    public BSTIterator(TreeNode root) {
        pushAll(root);
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    /** @return the next smallest number */
    public int next() {
        TreeNode tmpNode = stack.pop();
        pushAll(tmpNode.right);
        return tmpNode.val;
    }
    
    private void pushAll(TreeNode node) {
        for (; node != null; stack.push(node), node = node.left);
    }
}



Que3:
Design a data structure that supports adding new words and finding if a string matches any previously added string.

Implement the WordDictionary class:

WordDictionary() Initializes the object.
void addWord(word) Adds word to the data structure, it can be matched later.
bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.
 

Example:

Input
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
Output
[null,null,null,null,false,true,true,true]

Explanation
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // return False
wordDictionary.search("bad"); // return True
wordDictionary.search(".ad"); // return True
wordDictionary.search("b.."); // return True
 

Solution:
class WordDictionary {
    private WordDictionary[] children;
    boolean isEndOfWord;
    // Initialize your data structure here. 
    public WordDictionary() {
        children = new WordDictionary[26];
        isEndOfWord = false;
    }
    
    // Adds a word into the data structure. 
    public void addWord(String word) {
        WordDictionary curr = this;
        for(char c: word.toCharArray()){
            if(curr.children[c - 'a'] == null)
                curr.children[c - 'a'] = new WordDictionary();
            curr = curr.children[c - 'a'];
        }
        curr.isEndOfWord = true;
    }
    
    // Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. 
    public boolean search(String word) {
        WordDictionary curr = this;
        for(int i = 0; i < word.length(); ++i){
            char c = word.charAt(i);
            if(c == '.'){
                for(WordDictionary ch: curr.children)
                    if(ch != null && ch.search(word.substring(i+1))) return true;
                return false;
            }
            if(curr.children[c - 'a'] == null) return false;
            curr = curr.children[c - 'a'];
        }
        return curr != null && curr.isEndOfWord;
    }
}

Que4:
Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).

Implement the MyQueue class:

void push(int x) Pushes element x to the back of the queue.
int pop() Removes the element from the front of the queue and returns it.
int peek() Returns the element at the front of the queue.
boolean empty() Returns true if the queue is empty, false otherwise.
Notes:

You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.
Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.
 

Example 1:

Input
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 1, 1, false]

Explanation
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
 

Solution:
class MyQueue {

    private Queue<Integer> input;
    private Queue<Integer> output;

    public MyQueue() {
        input = new LinkedList<>();
        output = new LinkedList<>();
    }

    public void push(int x) {
        input.offer(x);
    }

    public int pop() {
        peek();
        return output.poll();
    }

    public int peek() {
        if (output.isEmpty()) {
            while (!input.isEmpty()) {
                output.offer(input.poll());
            }
        }
        return output.peek();
    }

    public boolean empty() {
        return input.isEmpty() && output.isEmpty();
    }
}


Que5:
Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations.

Implement the PeekingIterator class:

PeekingIterator(Iterator<int> nums) Initializes the object with the given integer iterator iterator.
int next() Returns the next element in the array and moves the pointer to the next element.
boolean hasNext() Returns true if there are still elements in the array.
int peek() Returns the next element in the array without moving the pointer.
Note: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions.


Example 1:

Input
["PeekingIterator", "next", "peek", "next", "next", "hasNext"]
[[[1, 2, 3]], [], [], [], [], []]
Output
[null, 1, 2, 2, 3, false]

Explanation
PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]
peekingIterator.next();    // return 1, the pointer moves to the next element [1,2,3].
peekingIterator.peek();    // return 2, the pointer does not move [1,2,3].
peekingIterator.next();    // return 2, the pointer moves to the next element [1,2,3]
peekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]
peekingIterator.hasNext(); // return False



Solution:
class PeekingIterator : public Iterator {
    int next_val; // keep a variable for storing the "next value" for use in "peek" function
    bool iter_hasnext; // for storing the "has next value"
public:
	PeekingIterator(const vector<int>& nums) : Iterator(nums) {
        iter_hasnext=Iterator::hasNext(); // store current has_next value
	    if (iter_hasnext)
            next_val = Iterator::next(); // store the "next_val" for "future" use in "peek" function
	}
	
	int peek() {
        return next_val; // return current next_val
	}
	
	int next() {
	    int curr_next = next_val; // store the current next for returning
        
        iter_hasnext=Iterator::hasNext(); // change the iter_hasnext variable
	    if (iter_hasnext) 
            next_val = Iterator::next(); // change the next_val and move the iterator to next position
        
	    return curr_next; // return the previously stored current next
	}
	
	bool hasNext() const {
	    return iter_hasnext; // return current iter_hashnext value
	}
};


Que6:
The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.

For example, for arr = [2,3,4], the median is 3.
For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.
Implement the MedianFinder class:

MedianFinder() initializes the MedianFinder object.
void addNum(int num) adds the integer num from the data stream to the data structure.
double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.
 

Example 1:

Input
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
Output
[null, null, null, 1.5, null, 2.0]

Explanation
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
 

Solution:
private PriorityQueue<Integer> small = new PriorityQueue<>(Collections.reverseOrder());
private PriorityQueue<Integer> large = new PriorityQueue<>();
private boolean even = true;

public double findMedian() {
    if (even)
        return (small.peek() + large.peek()) / 2.0;
    else
        return small.peek();
}

public void addNum(int num) {
    if (even) {
        large.offer(num);
        small.offer(large.poll());
    } else {
        small.offer(num);
        large.offer(small.poll());
    }
    even = !even;
}



Que7:
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.

 

Example 1:


Input: root = [1,2,3,null,null,4,5]
Output: [1,2,3,null,null,4,5]
Example 2:

Input: root = []
Output: []
 

Solution:
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        List<String> res = new ArrayList<>();
        buildString(root, res);
        return String.join(",", res);
    }

    private void buildString(TreeNode node, List<String> res) {
        if (node == null) {
            res.add("N");
        } else {
            res.add(String.valueOf(node.val));
            buildString(node.left, res);
            buildString(node.right, res);
        }
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] nodeValues = data.split(",");
        index = 0;
        return buildTree(nodeValues);
    }

    private int index;
    private TreeNode buildTree(String[] nodeValues) {
        if (nodeValues[index].equals("N")) {
            index++;
            return null;
        }
        TreeNode node = new TreeNode(Integer.parseInt(nodeValues[index]));
        index++;
        node.left = buildTree(nodeValues);
        node.right = buildTree(nodeValues);
        return node;
    }
}



Que8:
Given an integer array nums, handle multiple queries of the following type:

Calculate the sum of the elements of nums between indices left and right inclusive where left <= right.
Implement the NumArray class:

NumArray(int[] nums) Initializes the object with the integer array nums.
int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).
 

Example 1:

Input
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
Output
[null, 1, -1, -3]

Explanation
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1
numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1
numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3
 

Solution:
class NumArray {
    private int[] seg;
    private int[] num;
    public NumArray(int[] nums) {
        int n = nums.length;
        num = nums;
        seg = new int[4*n];
        build(0, 0, n-1);
    }
    
    public int sumRange(int left, int right) {
        return query(0, 0, num.length-1, left, right);
    }

    int query(int ind, int low, int high, int l, int r){
        if(low>=l && high<=r)// Total overlap
            return seg[ind];
        
        if(high<l || low>r) return 0; //no Overlap
        //Partial overlap
        int mid = (low+high)/2;
        int left = query(2*ind+1, low, mid, l, r);
        int right = query(2*ind+2, mid+1, high, l, r);

        return left+right;
    }

    void build(int ind, int low, int high){
        if(low==high){
            seg[ind] = num[low];
            return;
        }
        int mid = (low+high)/2;
        build(2*ind+1, low, mid);
        build(2*ind+2, mid+1, high);

        seg[ind] = seg[2*ind+1]+seg[2*ind+2];
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * int param_1 = obj.sumRange(left,right);
 */



Que9:
You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.

Implement the NestedIterator class:

NestedIterator(List<NestedInteger> nestedList) Initializes the iterator with the nested list nestedList.
int next() Returns the next integer in the nested list.
boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.
Your code will be tested with the following pseudocode:

initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
If res matches the expected flattened list, then your code will be judged as correct.

 

Example 1:

Input: nestedList = [[1,1],2,[1,1]]
Output: [1,1,2,1,1]
Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].
Example 2:

Input: nestedList = [1,[4,[6]]]
Output: [1,4,6]
Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].
 
Solution:
public class NestedIterator implements Iterator<Integer> {
    private Stack<NestedInteger> stack;
    
    public NestedIterator(List<NestedInteger> nestedList) {
        stack = new Stack<>();
        for (int i = nestedList.size() - 1; i >= 0; i--) {
            stack.push(nestedList.get(i));
        }        
    }

    @Override
    public Integer next() {
        return stack.pop().getInteger();        
    }

    @Override
    public boolean hasNext() {
        while (!stack.isEmpty()) {
            NestedInteger current = stack.peek();
            if (current.isInteger()) {
                return true;
            }
            stack.pop();
            List<NestedInteger> nestedList = current.getList();
            for (int i = nestedList.size() - 1; i >= 0; i--) {
                stack.push(nestedList.get(i));
            }
        }
        return false;        
    }
}



Que10:
Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals.

Implement the SummaryRanges class:

SummaryRanges() Initializes the object with an empty stream.
void addNum(int value) Adds the integer value to the stream.
int[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi]. The answer should be sorted by starti.
 

Example 1:

Input
["SummaryRanges", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals"]
[[], [1], [], [3], [], [7], [], [2], [], [6], []]
Output
[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]

Explanation
SummaryRanges summaryRanges = new SummaryRanges();
summaryRanges.addNum(1);      // arr = [1]
summaryRanges.getIntervals(); // return [[1, 1]]
summaryRanges.addNum(3);      // arr = [1, 3]
summaryRanges.getIntervals(); // return [[1, 1], [3, 3]]
summaryRanges.addNum(7);      // arr = [1, 3, 7]
summaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]
summaryRanges.addNum(2);      // arr = [1, 2, 3, 7]
summaryRanges.getIntervals(); // return [[1, 3], [7, 7]]
summaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]
summaryRanges.getIntervals(); // return [[1, 3], [6, 7]]
 

Solution:
class SummaryRanges {
    TreeSet<Integer> nums;
    SummaryRanges() {
        nums = new TreeSet<>();
    }
    
    void addNum(int value) {
        nums.add(value);
    }
    
    int[][] getIntervals() {
        int[][] intervals;
        int start = nums.first();
        int end = nums.first();
        int i = 0;
        for (Integer val : nums.tailSet(nums.first()+1)) {
            if (val - end == 1) {
                end = val;
            } else {
                intervals[i][0] = start;
                intervals[i][1] = end;
                i++;
                start = end = val;
            }
        }
        intervals[i][0] = start;
        intervals[i][1] = end;
        return intervals;
    }
}


Que11:
Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.

Implement the Twitter class:

Twitter() Initializes your twitter object.
void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.
List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.
void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.
void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.
 

Example 1:

Input
["Twitter", "postTweet", "getNewsFeed", "follow", "postTweet", "getNewsFeed", "unfollow", "getNewsFeed"]
[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]
Output
[null, null, [5], null, null, [6, 5], null, [5]]

Explanation
Twitter twitter = new Twitter();
twitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).
twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]
twitter.follow(1, 2);    // User 1 follows user 2.
twitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).
twitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.
twitter.unfollow(1, 2);  // User 1 unfollows user 2.
twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.
 

Solution:
public class Twitter {
	private static int timeStamp=0;

	// easy to find if user exist
	private Map<Integer, User> userMap;

	// Tweet link to next Tweet so that we can save a lot of time
	// when we execute getNewsFeed(userId)
	private class Tweet{
		public int id;
		public int time;
		public Tweet next;

		public Tweet(int id){
			this.id = id;
			time = timeStamp++;
			next=null;
		}
	}


	// OO design so User can follow, unfollow and post itself
	public class User{
		public int id;
		public Set<Integer> followed;
		public Tweet tweet_head;

		public User(int id){
			this.id=id;
			followed = new HashSet<>();
			follow(id); // first follow itself
			tweet_head = null;
		}

		public void follow(int id){
			followed.add(id);
		}

		public void unfollow(int id){
			followed.remove(id);
		}


		// everytime user post a new tweet, add it to the head of tweet list.
		public void post(int id){
			Tweet t = new Tweet(id);
			t.next=tweet_head;
			tweet_head=t;
		}
	}




	/** Initialize your data structure here. */
	public Twitter() {
		userMap = new HashMap<Integer, User>();
	}

	/** Compose a new tweet. */
	public void postTweet(int userId, int tweetId) {
		if(!userMap.containsKey(userId)){
			User u = new User(userId);
			userMap.put(userId, u);
		}
		userMap.get(userId).post(tweetId);

	}



	// Best part of this.
	// first get all tweets lists from one user including itself and all people it followed.
	// Second add all heads into a max heap. Every time we poll a tweet with 
	// largest time stamp from the heap, then we add its next tweet into the heap.
	// So after adding all heads we only need to add 9 tweets at most into this 
	// heap before we get the 10 most recent tweet.
	public List<Integer> getNewsFeed(int userId) {
		List<Integer> res = new LinkedList<>();

		if(!userMap.containsKey(userId))   return res;

		Set<Integer> users = userMap.get(userId).followed;
		PriorityQueue<Tweet> q = new PriorityQueue<Tweet>(users.size(), (a,b)->(b.time-a.time));
		for(int user: users){
			Tweet t = userMap.get(user).tweet_head;
			// very imporant! If we add null to the head we are screwed.
			if(t!=null){
				q.add(t);
			}
		}
		int n=0;
		while(!q.isEmpty() && n<10){
		  Tweet t = q.poll();
		  res.add(t.id);
		  n++;
		  if(t.next!=null)
			q.add(t.next);
		}

		return res;

	}

	/** Follower follows a followee. If the operation is invalid, it should be a no-op. */
	public void follow(int followerId, int followeeId) {
		if(!userMap.containsKey(followerId)){
			User u = new User(followerId);
			userMap.put(followerId, u);
		}
		if(!userMap.containsKey(followeeId)){
			User u = new User(followeeId);
			userMap.put(followeeId, u);
		}
		userMap.get(followerId).follow(followeeId);
	}

	/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */
	public void unfollow(int followerId, int followeeId) {
		if(!userMap.containsKey(followerId) || followerId==followeeId)
			return;
		userMap.get(followerId).unfollow(followeeId);
	}
}

/**
 * Your Twitter object will be instantiated and called as such:
 * Twitter obj = new Twitter();
 * obj.postTweet(userId,tweetId);
 * List<Integer> param_2 = obj.getNewsFeed(userId);
 * obj.follow(followerId,followeeId);
 * obj.unfollow(followerId,followeeId);
 */


Que12:
Implement the RandomizedSet class:

RandomizedSet() Initializes the RandomizedSet object.
bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
You must implement the functions of the class such that each function works in average O(1) time complexity.

 

Example 1:

Input
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
Output
[null, true, false, true, 2, true, false, 2]

Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
randomizedSet.insert(2); // 2 was already in the set, so return false.
randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.


Solution:
class RandomizedSet {

    private HashMap<Integer, Integer> map; 
    private ArrayList<Integer> list;       
    private Random rand;  

    public RandomizedSet() {
        map = new HashMap<>();
        list = new ArrayList<>();
        rand = new Random();
    }
    
    public boolean insert(int val) {
        if(map.containsKey(val)){
            return false;
        }

        list.add(val);
        map.put(val, list.size() - 1);
        return true;
    }
    
    public boolean remove(int val) {
        if(!map.containsKey(val)){
            return false;
        }

        int index = map.get(val);
        int lastElement = list.get(list.size() - 1);

        list.set(index, lastElement);
        map.put(lastElement, index);

        list.remove(list.size() - 1);
        map.remove(val);

        return true;
    }
    
    public int getRandom() {
        if (list.isEmpty()) {
            return -1; 
        }
        int randomIndex = rand.nextInt(list.size());
        return list.get(randomIndex);
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */


Que13:
Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.

Implement the Solution class:

Solution(int[] nums) Initializes the object with the integer array nums.
int[] reset() Resets the array to its original configuration and returns it.
int[] shuffle() Returns a random shuffling of the array.
 

Example 1:

Input
["Solution", "shuffle", "reset", "shuffle"]
[[[1, 2, 3]], [], [], []]
Output
[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]

Explanation
Solution solution = new Solution([1, 2, 3]);
solution.shuffle();    // Shuffle the array [1,2,3] and return its result.
                       // Any permutation of [1,2,3] must be equally likely to be returned.
                       // Example: return [3, 1, 2]
solution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]
solution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]

 
Solution:
class Solution {
    private int[] arr;
    private Random random;
    public Solution(int[] nums) {
        this.arr=nums;
        random = new Random();
    }
    
    public int[] reset() {
        return this.arr;
    }
    
    public int[] shuffle() {
        int shuffled[] = Arrays.copyOfRange(arr, 0, arr.length);
        for(int i= arr.length - 1;i>=0;--i){
            int j=random.nextInt(i+1);
            int temp=shuffled[i];
            shuffled[i]=shuffled[j];
            shuffled[j]=temp;
        }
        return shuffled;
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * int[] param_1 = obj.reset();
 * int[] param_2 = obj.shuffle();
 */


Que14:
Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.

Implement the AllOne class:

AllOne() Initializes the object of the data structure.
inc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.
dec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.
getMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string "".
getMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string "".
Note that each function must run in O(1) average time complexity.

 

Example 1:

Input
["AllOne", "inc", "inc", "getMaxKey", "getMinKey", "inc", "getMaxKey", "getMinKey"]
[[], ["hello"], ["hello"], [], [], ["leet"], [], []]
Output
[null, null, null, "hello", "hello", null, "hello", "leet"]

Explanation
AllOne allOne = new AllOne();
allOne.inc("hello");
allOne.inc("hello");
allOne.getMaxKey(); // return "hello"
allOne.getMinKey(); // return "hello"
allOne.inc("leet");
allOne.getMaxKey(); // return "hello"
allOne.getMinKey(); // return "leet"
 

Solution:
class AllOne {
    private Map<String, Integer> count;
    private TreeSet<Pair<Integer, String>> set;

    public AllOne() {
        count = new HashMap<>();
        set = new TreeSet<>((a, b) -> a.getKey().equals(b.getKey()) ? a.getValue().compareTo(b.getValue()) : a.getKey() - b.getKey());
    }

    public void inc(String key) {
        int n = count.getOrDefault(key, 0);
        count.put(key, n + 1);
        set.remove(new Pair<>(n, key));
        set.add(new Pair<>(n + 1, key));
    }

    public void dec(String key) {
        int n = count.get(key);
        set.remove(new Pair<>(n, key));
        if (n == 1) count.remove(key);
        else {
            count.put(key, n - 1);
            set.add(new Pair<>(n - 1, key));
        }
    }

    public String getMaxKey() {
        return set.isEmpty() ? "" : set.last().getValue();
    }

    public String getMinKey() {
        return set.isEmpty() ? "" : set.first().getValue();
    }
}


Que15:
Design and implement a data structure for a Least Frequently Used (LFU) cache.

Implement the LFUCache class:

LFUCache(int capacity) Initializes the object with the capacity of the data structure.
int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1.
void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated.
To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key.

When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it.

The functions get and put must each run in O(1) average time complexity.

 

Example 1:

Input
["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]

Explanation
// cnt(x) = the use counter for key x
// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // return 1
                 // cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.
                 // cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.
                 // cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // return 4
                 // cache=[4,3], cnt(4)=2, cnt(3)=3
 
Solution:
class LFUCache {
  public LFUCache(int capacity) {
    this.capacity = capacity;
  }

  public int get(int key) {
    if (!keyToVal.containsKey(key))
      return -1;

    final int freq = keyToFreq.get(key);
    freqToLRUKeys.get(freq).remove(key);
    if (freq == minFreq && freqToLRUKeys.get(freq).isEmpty()) {
      freqToLRUKeys.remove(freq);
      ++minFreq;
    }

    // Increase key's freq by 1
    // Add this key to next freq's list
    putFreq(key, freq + 1);
    return keyToVal.get(key);
  }

  public void put(int key, int value) {
    if (capacity == 0)
      return;
    if (keyToVal.containsKey(key)) {
      keyToVal.put(key, value);
      get(key); // Update key's count
      return;
    }

    if (keyToVal.size() == capacity) {
      // Evict LRU key from the minFreq list
      final int keyToEvict = freqToLRUKeys.get(minFreq).iterator().next();
      freqToLRUKeys.get(minFreq).remove(keyToEvict);
      keyToVal.remove(keyToEvict);
    }

    minFreq = 1;
    putFreq(key, minFreq);    // Add new key and freq
    keyToVal.put(key, value); // Add new key and value
  }

  private int capacity;
  private int minFreq = 0;
  private Map<Integer, Integer> keyToVal = new HashMap<>();
  private Map<Integer, Integer> keyToFreq = new HashMap<>();
  private Map<Integer, LinkedHashSet<Integer>> freqToLRUKeys = new HashMap<>();

  private void putFreq(int key, int freq) {
    keyToFreq.put(key, freq);
    freqToLRUKeys.putIfAbsent(freq, new LinkedHashSet<>());
    freqToLRUKeys.get(freq).add(key);
  }
}


Que 16:
Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle, and the last position is connected back to the first position to make a circle. It is also called "Ring Buffer".

One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.

Implement the MyCircularQueue class:

MyCircularQueue(k) Initializes the object with the size of the queue to be k.
int Front() Gets the front item from the queue. If the queue is empty, return -1.
int Rear() Gets the last item from the queue. If the queue is empty, return -1.
boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful.
boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful.
boolean isEmpty() Checks whether the circular queue is empty or not.
boolean isFull() Checks whether the circular queue is full or not.
You must solve the problem without using the built-in queue data structure in your programming language. 

 

Example 1:

Input
["MyCircularQueue", "enQueue", "enQueue", "enQueue", "enQueue", "Rear", "isFull", "deQueue", "enQueue", "Rear"]
[[3], [1], [2], [3], [4], [], [], [], [4], []]
Output
[null, true, true, true, false, 3, true, true, true, 4]

Explanation
MyCircularQueue myCircularQueue = new MyCircularQueue(3);
myCircularQueue.enQueue(1); // return True
myCircularQueue.enQueue(2); // return True
myCircularQueue.enQueue(3); // return True
myCircularQueue.enQueue(4); // return False
myCircularQueue.Rear();     // return 3
myCircularQueue.isFull();   // return True
myCircularQueue.deQueue();  // return True
myCircularQueue.enQueue(4); // return True
myCircularQueue.Rear();     // return 4
 
Solution:
class MyCircularQueue {
        final int[] a;
        int front = 0, rear = -1, len = 0;

        public MyCircularQueue(int k) { a = new int[k];}

        public boolean enQueue(int val) {
            if (!isFull()) {
                rear = (rear + 1) % a.length;
                a[rear] = val;
                len++;
                return true;
            } else return false;
        }

        public boolean deQueue() {
            if (!isEmpty()) {
                front = (front + 1) % a.length;
                len--;
                return true;
            } else return false;
        }

        public int Front() { return isEmpty() ? -1 : a[front];}

        public int Rear() {return isEmpty() ? -1 : a[rear];}

        public boolean isEmpty() { return len == 0;}

        public boolean isFull() { return len == a.length;}
    }

Que17:
Design a data structure that is initialized with a list of different words. Provided a string, you should determine if you can change exactly one character in this string to match any word in the data structure.

Implement the MagicDictionary class:

MagicDictionary() Initializes the object.
void buildDict(String[] dictionary) Sets the data structure with an array of distinct strings dictionary.
bool search(String searchWord) Returns true if you can change exactly one character in searchWord to match any string in the data structure, otherwise returns false.
 

Example 1:

Input
["MagicDictionary", "buildDict", "search", "search", "search", "search"]
[[], [["hello", "leetcode"]], ["hello"], ["hhllo"], ["hell"], ["leetcoded"]]
Output
[null, null, false, true, false, false]

Explanation
MagicDictionary magicDictionary = new MagicDictionary();
magicDictionary.buildDict(["hello", "leetcode"]);
magicDictionary.search("hello"); // return False
magicDictionary.search("hhllo"); // We can change the second 'h' to 'e' to match "hello" so we return True
magicDictionary.search("hell"); // return False
magicDictionary.search("leetcoded"); // return False
 
Solution:
class MagicDictionary {

    Map<String, List<int[]>> map = new HashMap<>();
    /** Initialize your data structure here. */
    public MagicDictionary() {
    }
    
    /** Build a dictionary through a list of words */
    public void buildDict(String[] dict) {
        for (String s : dict) {
            for (int i = 0; i < s.length(); i++) {
                String key = s.substring(0, i) + s.substring(i + 1);
                int[] pair = new int[] {i, s.charAt(i)};
                
                List<int[]> val = map.getOrDefault(key, new ArrayList<int[]>());
                val.add(pair);
                
                map.put(key, val);
            }
        }
    }
    
    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */
    public boolean search(String word) {
        for (int i = 0; i < word.length(); i++) {
            String key = word.substring(0, i) + word.substring(i + 1);
            if (map.containsKey(key)) {
                for (int[] pair : map.get(key)) {
                    if (pair[0] == i && pair[1] != word.charAt(i)) return true;
                }
            }
        }
        return false;
    }
}


Que18:
Design a map that allows you to do the following:

Maps a string key to a given value.
Returns the sum of the values that have a key with a prefix equal to a given string.
Implement the MapSum class:

MapSum() Initializes the MapSum object.
void insert(String key, int val) Inserts the key-val pair into the map. If the key already existed, the original key-value pair will be overridden to the new one.
int sum(string prefix) Returns the sum of all the pairs' value whose key starts with the prefix.
 

Example 1:

Input
["MapSum", "insert", "sum", "insert", "sum"]
[[], ["apple", 3], ["ap"], ["app", 2], ["ap"]]
Output
[null, null, 3, null, 5]

Explanation
MapSum mapSum = new MapSum();
mapSum.insert("apple", 3);  
mapSum.sum("ap");           // return 3 (apple = 3)
mapSum.insert("app", 2);    
mapSum.sum("ap");           // return 5 (apple + app = 3 + 2 = 5)
 
Solution:
class TrieNode {
    TrieNode[] child = new TrieNode[26];
    int sum = 0; // Store the sum of values of all strings go through this node.
}

class MapSum { // 10 ms, faster than 100.00%
    HashMap<String, Integer> map = new HashMap<>();
    TrieNode trieRoot = new TrieNode();

    public void insert(String key, int val) {
        int diff = val - map.getOrDefault(key, 0);
        TrieNode curr = trieRoot;
        for (char c : key.toCharArray()) {
            c -= 'a';
            if (curr.child[c] == null) curr.child[c] = new TrieNode();
            curr = curr.child[c];
            curr.sum += diff;
        }
        map.put(key, val);
    }
    public int sum(String prefix) {
        TrieNode curr = trieRoot;
        for (char c : prefix.toCharArray()) {
            c -= 'a';
            if (curr.child[c] == null) return 0;
            curr = curr.child[c];
        }
        return curr.sum;
    }
}


Que19:
You are part of a university admissions office and need to keep track of the kth highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores.

You are tasked to implement a class which, for a given integer k, maintains a stream of test scores and continuously returns the kth highest test score after a new score has been submitted. More specifically, we are looking for the kth highest score in the sorted list of all scores.

Implement the KthLargest class:

KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of test scores nums.
int add(int val) Adds a new test score val to the stream and returns the element representing the kth largest element in the pool of test scores so far.
 

Example 1:

Input:
["KthLargest", "add", "add", "add", "add", "add"]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]

Output: [null, 4, 5, 5, 8, 8]

Explanation:

KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3); // return 4
kthLargest.add(5); // return 5
kthLargest.add(10); // return 5
kthLargest.add(9); // return 8
kthLargest.add(4); // return 8

Example 2:

Input:
["KthLargest", "add", "add", "add", "add"]
[[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]

Output: [null, 7, 7, 7, 8]

Explanation:

KthLargest kthLargest = new KthLargest(4, [7, 7, 7, 7, 8, 3]);
kthLargest.add(2); // return 7
kthLargest.add(10); // return 7
kthLargest.add(9); // return 7
kthLargest.add(9); // return 8
 

Solution:
class KthLargest {
    private int k;
    private PriorityQueue<Integer> minHeap;

    public KthLargest(int k, int[] nums) {
        this.k = k;
        minHeap = new PriorityQueue<>(k);
        for (int num : nums) {
            if (minHeap.size() < k) {
                minHeap.offer(num);
            } else if (num > minHeap.peek()) {
                minHeap.offer(num);
                if (minHeap.size() > k) {
                    minHeap.poll();
                }
            }
        }
    }

    public int add(int val) {
        if (minHeap.size() < k) {
            minHeap.offer(val);
        } else if (val > minHeap.peek()) {
            minHeap.offer(val);
            minHeap.poll();
        }
        return minHeap.peek();
    }
}


Que20:
Design a HashSet without using any built-in hash table libraries.

Implement MyHashSet class:

void add(key) Inserts the value key into the HashSet.
bool contains(key) Returns whether the value key exists in the HashSet or not.
void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing.
 

Example 1:

Input
["MyHashSet", "add", "add", "contains", "contains", "add", "contains", "remove", "contains"]
[[], [1], [2], [1], [3], [2], [2], [2], [2]]
Output
[null, null, null, true, false, null, true, null, false]

Explanation
MyHashSet myHashSet = new MyHashSet();
myHashSet.add(1);      // set = [1]
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(1); // return True
myHashSet.contains(3); // return False, (not found)
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(2); // return True
myHashSet.remove(2);   // set = [1]
myHashSet.contains(2); // return False, (already removed)
 

Solution:
class MyHashSet {
    int n = 10000;
    List<Integer>[] arr;

    public MyHashSet() {
        arr = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            arr[i] = new ArrayList<>();
        }
    }

    public void add(int key) {
        int idx = key % n;
        if (!arr[idx].contains(key)) {
            arr[idx].add(key);
        }
    }

    public void remove(int key) {
        int idx = key % n;
        arr[idx].remove(Integer.valueOf(key));
    }

    public boolean contains(int key) {
        int idx = key % n;
        return arr[idx].contains(key);
    }
}

Que21:
A Range Module is a module that tracks ranges of numbers. Design a data structure to track the ranges represented as half-open intervals and query about them.

A half-open interval [left, right) denotes all the real numbers x where left <= x < right.

Implement the RangeModule class:

RangeModule() Initializes the object of the data structure.
void addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked.
boolean queryRange(int left, int right) Returns true if every real number in the interval [left, right) is currently being tracked, and false otherwise.
void removeRange(int left, int right) Stops tracking every real number currently being tracked in the half-open interval [left, right).
 

Example 1:

Input
["RangeModule", "addRange", "removeRange", "queryRange", "queryRange", "queryRange"]
[[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]
Output
[null, null, null, true, false, true]

Explanation
RangeModule rangeModule = new RangeModule();
rangeModule.addRange(10, 20);
rangeModule.removeRange(14, 16);
rangeModule.queryRange(10, 14); // return True,(Every number in [10, 14) is being tracked)
rangeModule.queryRange(13, 15); // return False,(Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)
rangeModule.queryRange(16, 17); // return True, (The number 16 in [16, 17) is still being tracked, despite the remove operation)
 

Solution:
class RangeModule {
    TreeMap<Integer, Integer> m = new TreeMap<>();
    public RangeModule() {}
    
    public void addRange(int s, int e) { // s: start, e: end
        // find overlap ranges, calc merged range, clear overlapped ranges, insert merged range
        var L = m.floorEntry(s); // left possible overlap entry
        var R = m.floorEntry(e); // right possible overlap entry

        if (L != null && L.getValue() >= s) s = L.getKey(); // update overlap start
        if (R != null && R.getValue() > e) e = R.getValue(); // update overlap end

        m.subMap(s, e).clear(); // clear all overlapped entries
        m.put(s, e); // save final merged entry
    }
    
    public boolean queryRange(int s, int e) {
        var L = m.floorEntry(s);
        return L != null && L.getValue() >= e; // if there exist a range: start <+ s, end >= e
    }
    
    public void removeRange(int s, int e) {
        var L = m.floorEntry(s); // left possible overlap entry
        var R = m.floorEntry(e); // right possible overlap entry

        if (L != null && L.getValue() > s) m.put(L.getKey(), s); // after removal, if anything left
        if (R != null && R.getValue() > e) m.put(e, R.getValue()); // after removal, if anything left

        m.subMap(s, e).clear(); // removal
    }
}

/**
 * Your RangeModule object will be instantiated and called as such:
 * RangeModule obj = new RangeModule();
 * obj.addRange(left,right);
 * boolean param_2 = obj.queryRange(left,right);
 * obj.removeRange(left,right);
 */


Que22:
You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking.

A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.).

The event can be represented as a pair of integers startTime and endTime that represents a booking on the half-open interval [startTime, endTime), the range of real numbers x such that startTime <= x < endTime.

Implement the MyCalendar class:

MyCalendar() Initializes the calendar object.
boolean book(int startTime, int endTime) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.
 

Example 1:

Input
["MyCalendar", "book", "book", "book"]
[[], [10, 20], [15, 25], [20, 30]]
Output
[null, true, false, true]

Explanation
MyCalendar myCalendar = new MyCalendar();
myCalendar.book(10, 20); // return True
myCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event.
myCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20.
 
Solution:
class MyCalendar {
    private List<int[]> books = new ArrayList<>();
    public boolean book(int start, int end) {
        for (int[] b : books)
            if (Math.max(b[0], start) < Math.min(b[1], end)) return false;
        books.add(new int[]{ start, end });
        return true;
    }
}


Que23:
Design a special dictionary that searches the words in it by a prefix and a suffix.

Implement the WordFilter class:

WordFilter(string[] words) Initializes the object with the words in the dictionary.
f(string pref, string suff) Returns the index of the word in the dictionary, which has the prefix pref and the suffix suff. If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1.
 

Example 1:

Input
["WordFilter", "f"]
[[["apple"]], ["a", "e"]]
Output
[null, 0]
Explanation
WordFilter wordFilter = new WordFilter(["apple"]);
wordFilter.f("a", "e"); // return 0, because the word at index 0 has prefix = "a" and suffix = "e".
 
Solution:
class WordFilter {
    // Trie Node with HashMap for memory-efficient storage
    class Node {
        Map<Character, Node> children = new HashMap<>();
        int indices; // Store all word indices
    }

    private Node root = new Node(); // Root node for the Trie

    /**
     * Constructor: Inserts words in a special format "suffix#word" into the trie.
     * @param words - Array of words
     */
    public WordFilter(String[] words) {
        for (int i = 0; i < words.length; i++) {
            String word = words[i];
            int n = word.length();

            // Insert all possible suffix-prefix combinations into the trie
            for (int j = 0; j <= n; j++) {
                String newWord = word.substring(j) + "#" + word;
                insert(newWord, i);
            }
        }
    }

    /**
     * Inserts a word into the Trie.
     * @param word - The word in "suffix#word" format
     * @param idx - The index of the word in the input array
     */
    private void insert(String word, int idx) {
        Node curr = root;
        for (char c : word.toCharArray()) {
            curr.children.putIfAbsent(c, new Node()); // Create a new node if needed
            curr = curr.children.get(c);
            curr.indices = idx; // Store index at each node
        }
    }

    /**
     * Finds the highest index of a word that matches the prefix and suffix.
     * @param pref - The prefix to search for
     * @param suff - The suffix to search for
     * @return - The highest index of a matching word, or -1 if no match
     */
    public int f(String pref, String suff) {
        String query = suff + "#" + pref; // Formulate the search key
        Node curr = root;

        // Traverse the trie for the given query string
        for (char c : query.toCharArray()) {
            if (!curr.children.containsKey(c)) {
                return -1; // No match found
            }
            curr = curr.children.get(c);
        }

        // Get the latest index from the stored indices list
        return curr.indices;
    }
}


Que24:
There is an exam room with n seats in a single row labeled from 0 to n - 1.

When a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. If no one is in the room, then the student sits at seat number 0.

Design a class that simulates the mentioned exam room.

Implement the ExamRoom class:

ExamRoom(int n) Initializes the object of the exam room with the number of the seats n.
int seat() Returns the label of the seat at which the next student will set.
void leave(int p) Indicates that the student sitting at seat p will leave the room. It is guaranteed that there will be a student sitting at seat p.
 

Example 1:

Input
["ExamRoom", "seat", "seat", "seat", "seat", "leave", "seat"]
[[10], [], [], [], [], [4], []]
Output
[null, 0, 9, 4, 2, null, 5]

Explanation
ExamRoom examRoom = new ExamRoom(10);
examRoom.seat(); // return 0, no one is in the room, then the student sits at seat number 0.
examRoom.seat(); // return 9, the student sits at the last seat number 9.
examRoom.seat(); // return 4, the student sits at the last seat number 4.
examRoom.seat(); // return 2, the student sits at the last seat number 2.
examRoom.leave(4);
examRoom.seat(); // return 5, the student sits at the last seat number 5.

 
Solution:
    int N;
    ArrayList<Integer> L = new ArrayList<>();
    public ExamRoom(int n) {
        N = n;
    }

    public int seat() {
        if (L.size() == 0) {
            L.add(0);
            return 0;
        }
        int d = Math.max(L.get(0), N - 1 - L.get(L.size() - 1));
        for (int i = 0; i < L.size() - 1; ++i) d = Math.max(d, (L.get(i + 1) - L.get(i)) / 2);
        if (L.get(0) == d) {
            L.add(0, 0);
            return 0;
        }
        for (int i = 0; i < L.size() - 1; ++i)
            if ((L.get(i + 1) - L.get(i)) / 2 == d) {
                L.add(i + 1, (L.get(i + 1) + L.get(i)) / 2);
                return L.get(i + 1);
            }
        L.add(N - 1);
        return N - 1;
    }

    public void leave(int p) {
        for (int i = 0; i < L.size(); ++i) if (L.get(i) == p) L.remove(i);
    }

Que25:
Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.

Implement the FreqStack class:

FreqStack() constructs an empty frequency stack.
void push(int val) pushes an integer val onto the top of the stack.
int pop() removes and returns the most frequent element in the stack.
If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.
 

Example 1:

Input
["FreqStack", "push", "push", "push", "push", "push", "push", "pop", "pop", "pop", "pop"]
[[], [5], [7], [5], [7], [4], [5], [], [], [], []]
Output
[null, null, null, null, null, null, null, 5, 7, 5, 4]

Explanation
FreqStack freqStack = new FreqStack();
freqStack.push(5); // The stack is [5]
freqStack.push(7); // The stack is [5,7]
freqStack.push(5); // The stack is [5,7,5]
freqStack.push(7); // The stack is [5,7,5,7]
freqStack.push(4); // The stack is [5,7,5,7,4]
freqStack.push(5); // The stack is [5,7,5,7,4,5]
freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].
freqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].
freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].
freqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].
 
Solution:
class FreqStack {
    HashMap<Integer, Integer> freq = new HashMap<>();
    HashMap<Integer, Stack<Integer>> m = new HashMap<>();
    int maxfreq = 0;

    public void push(int x) {
        int f = freq.getOrDefault(x, 0) + 1;
        freq.put(x, f);
        maxfreq = Math.max(maxfreq, f);
        if (!m.containsKey(f)) m.put(f, new Stack<Integer>());
        m.get(f).add(x);
    }

    public int pop() {
        int x = m.get(maxfreq).pop();
        freq.put(x, maxfreq - 1);
        if (m.get(maxfreq).size() == 0) maxfreq--;
        return x;
    }
}

Que26:
Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day.

The span of the stock's price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.

For example, if the prices of the stock in the last four days is [7,2,1,2] and the price of the stock today is 2, then the span of today is 4 because starting from today, the price of the stock was less than or equal 2 for 4 consecutive days.
Also, if the prices of the stock in the last four days is [7,34,1,2] and the price of the stock today is 8, then the span of today is 3 because starting from today, the price of the stock was less than or equal 8 for 3 consecutive days.
Implement the StockSpanner class:

StockSpanner() Initializes the object of the class.
int next(int price) Returns the span of the stock's price given that today's price is price.
 

Example 1:

Input
["StockSpanner", "next", "next", "next", "next", "next", "next", "next"]
[[], [100], [80], [60], [70], [60], [75], [85]]
Output
[null, 1, 1, 1, 2, 1, 4, 6]

Explanation
StockSpanner stockSpanner = new StockSpanner();
stockSpanner.next(100); // return 1
stockSpanner.next(80);  // return 1
stockSpanner.next(60);  // return 1
stockSpanner.next(70);  // return 2
stockSpanner.next(60);  // return 1
stockSpanner.next(75);  // return 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.
stockSpanner.next(85);  // return 6
 
Solution:
import java.util.*;

class StockSpanner {

    Stack<Integer>s=new Stack<>();
    ArrayList<Integer>Stock=new ArrayList<>();
    ArrayList<Integer>span=new ArrayList<>();
        public StockSpanner() {
    }
    
    public int next(int price) {
    int i=Stock.size();
    Stock.add(price);
    span.add(1);
    while(!s.isEmpty()&&price>=Stock.get(s.peek())){
        s.pop();
    }
    if(s.isEmpty()){
        span.set(i,i+1);
    }else{
        int prevHigh=s.peek();
        span.set(i,i-s.peek());
    }
    s.push(i);
    return span.get(i);
    }
}

/**
 * Your StockSpanner object will be instantiated and called as such:
 * StockSpanner obj = new StockSpanner();
 * int param_1 = obj.next(price);
 */

Que27:
You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].

For each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.

Implement the TopVotedCandidate class:

TopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.
int q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.
 

Example 1:

Input
["TopVotedCandidate", "q", "q", "q", "q", "q", "q"]
[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]
Output
[null, 0, 1, 1, 0, 0, 1]

Explanation
TopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);
topVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.
topVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.
topVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)
topVotedCandidate.q(15); // return 0
topVotedCandidate.q(24); // return 0
topVotedCandidate.q(8); // return 1

 
Solution:
    Map<Integer, Integer> m = new HashMap<>();
    int[] time;
    public TopVotedCandidate(int[] persons, int[] times) {
        int n = persons.length, lead = -1;
        Map<Integer, Integer> count = new HashMap<>();
        time = times;
        for (int i = 0; i < n; ++i) {
            count.put(persons[i], count.getOrDefault(persons[i], 0) + 1);
            if (i == 0 || count.get(persons[i]) >= count.get(lead)) lead = persons[i];
            m.put(times[i], lead);
        }
    }

    public int q(int t) {
        int i = Arrays.binarySearch(time, t);
        return i < 0 ? m.get(time[-i-2]) : m.get(time[i]);
    }



Que28:
A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.

Design an algorithm to insert a new node to a complete binary tree keeping it complete after the insertion.

Implement the CBTInserter class:

CBTInserter(TreeNode root) Initializes the data structure with the root of the complete binary tree.
int insert(int v) Inserts a TreeNode into the tree with value Node.val == val so that the tree remains complete, and returns the value of the parent of the inserted TreeNode.
TreeNode get_root() Returns the root node of the tree.
 

Example 1:


Input
["CBTInserter", "insert", "insert", "get_root"]
[[[1, 2]], [3], [4], []]
Output
[null, 1, 2, [1, 2, 3, 4]]

Explanation
CBTInserter cBTInserter = new CBTInserter([1, 2]);
cBTInserter.insert(3);  // return 1
cBTInserter.insert(4);  // return 2
cBTInserter.get_root(); // return [1, 2, 3, 4]
 

Solution:
    List<TreeNode> tree;
    public CBTInserter(TreeNode root) {
        tree = new ArrayList<>();
        tree.add(root);
        for (int i = 0; i < tree.size(); ++i) {
            if (tree.get(i).left != null) tree.add(tree.get(i).left);
            if (tree.get(i).right != null) tree.add(tree.get(i).right);
        }
    }

    public int insert(int v) {
        int N = tree.size();
        TreeNode node = new TreeNode(v);
        tree.add(node);
        if (N % 2 == 1)
            tree.get((N - 1) / 2).left = node;
        else
            tree.get((N - 1) / 2).right = node;
        return tree.get((N - 1) / 2).val;
    }

    public TreeNode get_root() {
        return tree.get(0);
    }


Que29:
You have a RecentCounter class which counts the number of recent requests within a certain time frame.

Implement the RecentCounter class:

RecentCounter() Initializes the counter with zero recent requests.
int ping(int t) Adds a new request at time t, where t represents some time in milliseconds, and returns the number of requests that has happened in the past 3000 milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range [t - 3000, t].
It is guaranteed that every call to ping uses a strictly larger value of t than the previous call.

 

Example 1:

Input
["RecentCounter", "ping", "ping", "ping", "ping"]
[[], [1], [100], [3001], [3002]]
Output
[null, 1, 2, 3, 3]

Explanation
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1], range is [-2999,1], return 1
recentCounter.ping(100);   // requests = [1, 100], range is [-2900,100], return 2
recentCounter.ping(3001);  // requests = [1, 100, 3001], range is [1,3001], return 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002], range is [2,3002], return 3
 

Solution:
class RecentCounter {
    private static final int[] records = new int[10000]; //
    private int start;
    private int end;

    public RecentCounter() {        
        start = 0;
        end = 0;
    }
    
    public int ping(int t) {
        while (start < end && (t - records[start] > 3000)) { 
            start++; // if the difference in time is greater than 3000ms, 
            // than increase the value of start unitl it's equal or less than 3000ms.
        }
        records[end++] = t; // Inserting the current time at the end
        return end - start; // Returning the answer including the element added just now.
    }
}


Que30:
You have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum capacity.

Implement the DinnerPlates class:

DinnerPlates(int capacity) Initializes the object with the maximum capacity of the stacks capacity.
void push(int val) Pushes the given integer val into the leftmost stack with a size less than capacity.
int pop() Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns -1 if all the stacks are empty.
int popAtStack(int index) Returns the value at the top of the stack with the given index index and removes it from that stack or returns -1 if the stack with that given index is empty.
 

Example 1:

Input
["DinnerPlates", "push", "push", "push", "push", "push", "popAtStack", "push", "push", "popAtStack", "popAtStack", "pop", "pop", "pop", "pop", "pop"]
[[2], [1], [2], [3], [4], [5], [0], [20], [21], [0], [2], [], [], [], [], []]
Output
[null, null, null, null, null, null, 2, null, null, 20, 21, 5, 4, 3, 1, -1]

Explanation: 
DinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2
D.push(1);
D.push(2);
D.push(3);
D.push(4);
D.push(5);         // The stacks are now:  2  4
                                           1  3  5
                                           ﹈ ﹈ ﹈
D.popAtStack(0);   // Returns 2.  The stacks are now:     4
                                                       1  3  5
                                                       ﹈ ﹈ ﹈
D.push(20);        // The stacks are now: 20  4
                                           1  3  5
                                           ﹈ ﹈ ﹈
D.push(21);        // The stacks are now: 20  4 21
                                           1  3  5
                                           ﹈ ﹈ ﹈
D.popAtStack(0);   // Returns 20.  The stacks are now:     4 21
                                                        1  3  5
                                                        ﹈ ﹈ ﹈
D.popAtStack(2);   // Returns 21.  The stacks are now:     4
                                                        1  3  5
                                                        ﹈ ﹈ ﹈ 
D.pop()            // Returns 5.  The stacks are now:      4
                                                        1  3 
                                                        ﹈ ﹈  
D.pop()            // Returns 4.  The stacks are now:   1  3 
                                                        ﹈ ﹈   
D.pop()            // Returns 3.  The stacks are now:   1 
                                                        ﹈   
D.pop()            // Returns 1.  There are no stacks.
D.pop()            // Returns -1.  There are still no stacks.
 

Solution:
class DinnerPlates {

    Map<Integer, Stack<Integer>> map;
    int cap;
    int curr;
    int last;
    int count;
    
    public DinnerPlates(int capacity) {
        cap = capacity;
        curr = 0; //where to push element
        last = 0; //where to pop element
        count = 0; //number of elements
        map = new HashMap<>();
        map.put(curr, new Stack<>());
    }
    
    public void push(int val) {
        //do some preprocessing to update current index
        while(map.containsKey(curr) && map.get(curr).size()==cap){
            curr++;
        }
        if(!map.containsKey(curr)){
            map.put(curr, new Stack<>());
        }
        map.get(curr).push(val);
        last = Math.max(last, curr);
        count++;
    }
    
    public int pop() {
        if(count==0) return -1;
        while(last>=0 && map.get(last).isEmpty()){
            last--;
        }
        count--;
        curr=Math.min(curr, last);
        return map.get(last).pop();
    }
    
    public int popAtStack(int index) {
        if(!map.containsKey(index) || map.get(index).isEmpty()){
            return -1;
        }
        count--;
        curr=Math.min(curr, index);
        return map.get(index).pop();
    }
}








